import sys
import math
from random import *

import pygame
from pygame.locals import *

import enemy
import mapManager
import myHero
import plotManager

"""Êúâ3‰∏™ÈÄèÊòéÁîªÂ∏ÉÔºàsurfaceÔºâÂú®ÊâÄÊúâÂÖÉÁ¥†‰πã‰∏äÔºå‰∏ÄÊòØÁî®‰∫éÁîªËá™ÁÑ∂ÂÖÉÁ¥†ÔºàÂ¶ÇÈõ™ÔºåÈõ®ÔºâÔºõÁ¨¨‰∫å‰∏™ÊòØÁîªÂÖ®Â±èÊïàÊûúÁöÑÔºõÁ¨¨‰∏â‰∏™ÊòØÁî®‰∫éÁîªÂáª‰∏≠Êó∂ÁöÑË°ÄÁöÑÊ∫ÖÂ∞ÑÊïàÊûú"""

# =============================================================================================================
# -------------------------------------------------------------------------------------------------------------
# ------------------------------------ stage running class ----------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# =============================================================================================================
class AdventureModel():
    
    allElements = None    # a big Group for all sprites in this stage
    bg_size = ()          # Â±èÂπïÁöÑÂÆΩÈ´òÔºà‰∫åÂÖÉÁªÑÔºâ
    towerD = 10           # Âçï‰∫∫Ê®°Âºè‰∏∫10ÔºàÈªòËÆ§ÔºâÔºåÂèå‰∫∫Ê®°Âºè‰∏∫11
    towerH = 160
    blockSize = 72
    ctrY = -130           # Âè≥‰∏äËßíÊéß‰ª∂ÁöÑÊ∞¥Âπ≥ÂÅèÁßª‰ΩçÁΩÆÔºàÂÉèÁ¥†Ôºâ
    language = 0          # ÂàùÂßãÈªòËÆ§‰∏∫Ëã±ÊñáÔºåÂèØÂú®ÊûÑÈÄ†ÂáΩÊï∞‰∏≠ËÆæÂÆö
    fntSet = []
    remindedArea = []
    win = False           # Ê†áËÆ∞ÊúÄÁªàÁªìÊûú

    stg = 1
    curArea = 0
    scrnSpd = 4           # Â±èÂπï‰∏ä‰∏ãÁßªÂä®ÁöÑÈÄüÂ∫¶ÔºåÂçï‰ΩçÂÉèÁ¥†
    delay = 120           # Âª∂Êó∂ÂèòÈáèÔºåÁî®‰∫éÂú®‰∏çÂΩ±ÂìçÊ∏∏ÊàèÊ≠£Â∏∏ËøêË°åÁöÑÊÉÖÂÜµ‰∏ãÁªôÂõæÁâáÂàáÊç¢Â¢ûÂä†Âª∂Ëøü
    msgList = []          # Áî®‰∫éÂ≠òÂÇ®Ê∂àÊÅØÁöÑÂàóË°®ÔºàÂàóË°®ÂåÖÂê´ÂàóË°®ÔºâÔºö[ [heroName, incident, cntDown (,sticker)], ... ]
    subsList = []         # The buffer containing those newly opened chests' substances.
    vibration = 0         # Cnt to indicate the vibration of the screen.
    # Âèå‰∫∫Ê®°Âºè‰∏ãÁöÑÁâπÊÆäÂèòÈáè
    frontier = 0          # ‰∏§ËÄÖ‰∏≠ÁöÑËæÉÈ´òÂÉèÁ¥†ÂÄº
    frnLayer = 0          # ‰∏§ËÄÖ‰∏≠ÁöÑËæÉÈ´òÂ±ÇÊï∞

    heroes = []           # ‰øùÂ≠òheroÂØπË±°ÁöÑÂºïÁî®ÔºõÂèØËÉΩ‰∏∫1‰∏™Êàñ2‰∏™
    tomb = []
    tower = None
    screen = None         # ‰øùÂ≠òÂ±èÂπïÂØπË±°ÁöÑÂºïÁî®
    clock = None
    towerBG = None        # ÂΩìÂâçÂÖ≥Âç°ÁöÑËÉåÊôØjpg
    towerBGRect = None
    nature = None         # Ëá™ÁÑ∂ÂÖÉÁ¥†ÁöÑÁîªÂ∏É
    spurtCanvas = None    # Âáª‰∏≠ÂèçÈ¶àÊ∫ÖË°ÄÁöÑÁîªÂ∏ÉÔºàÊØî‰Ω†ÊÉ≥Ë±°‰∏≠ÁöÑÊõ¥‰∏áËÉΩÔºÅ‰∏çÂè™ÊòØËÉΩÁîªË°ÄÂô¢üòÑÂòªÂòªÔºâ
    haloCanvas = None     # bossÂá∫Áé∞Êó∂ÁöÑÂÖ®Â±èÈò¥ÂΩ±ÁîªÂ∏É
    plotManager = None    # ÁÆ°ÁêÜÂâßÊÉÖ‰ø°ÊÅØ

    msgStick = {}
    hostage = None
    natON = True          # Ëá™ÁÑ∂Ë£ÖÈ•∞ÊïàÊûúÊòØÂê¶ÂºÄÂêØ
    music = None          # bgm ÔºàSoundÂØπË±°Ôºâ
    controller = []       # Âè≥‰∏äËßíÊéß‰ª∂
    controllerOn = []
    paused = True
    musicOn = True
    setBG = False
    gameOn = True         # Ê∏∏ÊàèÂæ™ÁéØÊ†áÂøóÔºåÈªòËÆ§‰∏∫TrueÔºåÁé©ÂÆ∂ÁÇπÂáªÈÄÄÂá∫ÊàñÊ∏∏ÊàèÁªìÊùüÊó∂Âèò‰∏∫False

    # Êú¨modelÊûÑÈÄ†ÂáΩÊï∞ËØ¥ÊòéÔºö
    # heroInfoList ÊòØ‰∏Ä‰∏™ÂàóË°®ÔºåÂàóË°®ÁöÑÊØè‰∏ÄÈ°πÊòØ‰∏Ä‰∏™heroÁöÑ‰ø°ÊÅØÔºåÊØè‰∏ÄÈ°π‰ø°ÊÅØÂåÖÊã¨heroNoÂíåËØ•Ëã±ÈõÑÁöÑkeyDic„ÄÇÂç≥ÂΩ¢Â¶ÇÔºö[ (heroNo1, keyDic1), (heroNo2, keyDic2) ]„ÄÇÂèØ‰∏∫1-2‰∏™„ÄÇ
    def __init__(self, stg, areas, heroList, bg_size, screen, language, fntSet, musicObj, diffi, natON, monsDic, VHostage):
        
        self.allElements = pygame.sprite.Group()
        self.stg = stg
        self.screen = screen
        self.bg_size = bg_size
        self.language = language
        self.fntSet = fntSet
        self.natON = natON
        self.monsAcc = monsDic    # ÂΩìÂâçÂÖ≥Âç°ÁöÑÊâÄÊúâÊÄ™Áâ©ÂêçÂèäÂÖ∂VMonsÂØπË±°ÁªÑÊàêÁöÑÂ≠óÂÖ∏
        # Âè≥‰∏äËßíÁöÑÊéß‰ª∂ÂõæÁâá ÂèäÂÖ∂‰ªñÊéßÂà∂Âô®
        self.controller = [pygame.image.load("image/quit.png").convert_alpha(), 
            pygame.image.load("image/BGMusic.png").convert_alpha(), pygame.image.load("image/mute.png").convert_alpha()]
        self.controllerOn = [pygame.image.load("image/quitOn.png").convert_alpha(), 
            pygame.image.load("image/BGMusicOn.png").convert_alpha(), pygame.image.load("image/muteOn.png").convert_alpha()]
        self.aimImg = pygame.image.load("image/aim.png").convert_alpha()
        self.clock = pygame.time.Clock()
        self.music = musicObj
        self.msgStick = { "msg":pygame.image.load("image/tip.png").convert_alpha(), 
            "dlg":pygame.image.load("image/stg"+str(self.stg)+"/preFig.png").convert_alpha() }
        # Initialize game canvas.
        self.gameOn = True
        self.paused = True
        self.setBG = False
        self.nature = None
        if self.natON:
            if self.stg == 1:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 8, 1)
            elif self.stg == 2:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 1, 0)
            elif self.stg == 3:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 8, 1)
            elif self.stg == 4 or self.stg == 7:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 18, 0)
            elif self.stg == 5:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 10, -1)
            elif self.stg == 6:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 8, 1)
        self.spurtCanvas = mapManager.SpurtCanvas( self.bg_size )
        self.haloCanvas = mapManager.HaloCanvas( self.bg_size )
        # Select and overlap the moveMons() method.
        if self.stg == 1:
            self.moveMons = moveMonsStg1
        elif self.stg == 2:
            self.moveMons = moveMonsStg2
        elif self.stg == 3:
            self.moveMons = moveMonsStg3
        elif self.stg == 4:
            self.moveMons = moveMonsStg4
        elif self.stg == 5:
            self.moveMons = moveMonsStg5
        elif self.stg == 6:
            self.moveMons = moveMonsStg6
        elif self.stg == 7:
            self.moveMons = moveMonsStg7
        # Plot Manager & Effect Manager.
        self.plotManager = plotManager.Dialogue( stg )
        self.effecter = plotManager.Controller(bg_size)

        self.remindedArea = [0]    # Â≠òÂÇ®Â∑≤Âä†ËΩΩËøáÂÖ≥Âç°ÂØπËØùÁöÑÂå∫Âüü„ÄÇ
        for msg in self.plotManager.getPre(self.curArea):
            self.msgList.append( [ "message", msg, 150, self.msgStick["dlg"] ] )
        # towerËÉåÊôØÂõæÁâá ÂèäÂÖ∂ÁßªÂä®ÈÄüÂ∫¶
        self.towerBG = pygame.image.load( "image/stg"+ str(self.stg) +"/towerBG.jpg" ).convert()
        self.towerBGRect = self.towerBG.get_rect()
        self.towerBGRect.left = (self.bg_size[0]-self.towerBGRect.width) // 2
        self.towerBGRect.top = (self.bg_size[1]-self.towerBGRect.height) // 2
        if diffi == 0:
            dmgReduction = 0.6  # ‰º§ÂÆ≥ÂáèËΩª
            enemy.Monster.healthBonus = 0.8
            doubleP = 0.4       # ÂÆùÁÆ±ÁàÜÁéáÁøªÂÄçÁöÑÊ¶ÇÁéá
            self.towerH = 40    # ÊØèÂå∫ÂüüÂ±ÇÊï∞
        elif diffi == 1:
            dmgReduction = 1
            enemy.Monster.healthBonus = 1
            doubleP = 0.2
            self.towerH = 60
        elif diffi == 2:
            dmgReduction = 1.2
            enemy.Monster.healthBonus = 1.5
            doubleP = 0
            self.towerH = 80
        # create the map (note: for good influency of the screen, please no more than 240 layers) --------------- üèØ
        if len(heroList)>1:
            self.towerD = 11
        oriPos = ( (self.bg_size[0] - self.towerD*self.blockSize) // 2, self.bg_size[1]-self.blockSize )
        if self.stg==1 or self.stg==6:
            specialOn = (False, True, True)
        else:
            specialOn = (True, True, True)
        # Build 3 areas and link them as one big tower.
        tower0 = mapManager.AdventureTower(oriPos, self.blockSize, self.towerD, self.towerH, self.stg, 0, specialOn[0], doubleP)
        oriPos = tower0.generateMap()
        tower1 = mapManager.AdventureTower(oriPos, self.blockSize, self.towerD, self.towerH, self.stg, 1, specialOn[1], doubleP)
        oriPos = tower1.generateMap()
        tower2 = mapManager.AdventureTower(oriPos, self.blockSize, self.towerD, self.towerH, self.stg, 2, specialOn[2], doubleP)
        tower2.generateMap()
        self.areaList = [tower0, tower1, tower2]
        self.curArea = 0
        self.tower = self.areaList[self.curArea]
        self.hostage = None
        # create the hero -----------------üê∑
        self.tomb = []
        self.heroes = []
        for each in heroList:      # Ê†πÊçÆ‰º†ÂÖ•ÁöÑVHeroÂèÇÊï∞‰ø°ÊÅØÁîüÊàêhero
            if each[2] == "p1":
                propPos = { "slot":(-300,290), "ammo":(-335,268), "bag":(-230,268), "health":(115,660) }
                initPos = (tower0.boundaries[0]-self.blockSize-10, bg_size[1]-2*self.blockSize)
            elif each[2] == "p2":
                propPos = { "slot":(180,290), "ammo":(145,268), "bag":(250,268), "health":(595,660) }
                initPos = (tower0.boundaries[0]-self.blockSize+10, bg_size[1]-2*self.blockSize)
            hero = myHero.Hero(initPos, self.blockSize, each[0], propPos, dmgReduction )
            hero.keyDic = each[1]
            hero.haloCanvas = self.haloCanvas  # Âèó‰º§ÂèçÈ¶àÁîªÂ∏É
            self.heroes.append(hero)
            self.allElements.add(hero)
        # Initialize towers and heroes.
        for tower in self.areaList:
            # add elems of each area to the allElements and hero's checkList.
            for key in tower.groupList:
                for brick in tower.groupList[key]:
                    self.allElements.add( brick )    # Âä†ÂÖ•walls
                    if brick.category == "sideWall" or (brick.category == "baseWall" and brick.coord[1]==0):
                        for hero in self.heroes:
                            hero.checkList.add( brick )
            for sup in tower.chestList:
                if sup.category == "hostage":        # ÈÄâÂá∫hostageÊåÇÂú®self.hostage‰∏äÔºåÂπ∂ËÆæÁΩÆÂÖ∂VHeroÊâÄÈúÄÁöÑ‰ø°ÊÅØ„ÄÇ
                    self.hostage = sup
                    self.hostage.hp = VHostage.hp
                    self.hostage.pw = VHostage.pw
                    self.hostage.dmg = VHostage.dmg
                    self.hostage.no = VHostage.no
                    self.hostage.lvl = VHostage.lvl
                self.allElements.add(sup)            # Âä†ÂÖ•supply
                for hero in self.heroes:
                    hero.checkList.add(sup)
            for elem in tower.elemList:
                self.allElements.add(elem)
                for hero in self.heroes:
                    hero.checkList.add(elem)
            # create natural impediments and monsters for each area.
            if (self.stg==1):
                if tower.area == 0:
                    makeMons( 0, tower.layer, 0.7, 1, tower )
                elif tower.area == 1:
                    makeMons( 0, tower.layer, 0.65, 1, tower )
                    makeMons( 2, tower.layer, 0.45, 2, tower )
                elif tower.area == 2:
                    makeMons( 0, tower.layer, 0.55, 1, tower )
                    makeMons( 2, tower.layer, 0.4, 2, tower )
                    makeMons( 20, 22, 1, 3, tower )    # bossÂøÖÈ°ªÂá∫Áé∞ÔºåÊâÄ‰ª•Ê¶ÇÁéáÁªô1ÔºõÂ±ÇÊï∞ÁªôÊåáÂÆöÁöÑÂ±ÇÊï∞21(20~22‰πãÈó¥)
                    for i in range(2):
                        f = enemy.InfernoFire(self.bg_size)
                        self.allElements.add(f)
            elif (self.stg==2):
                if tower.area == 0:
                    makeMons( 0, tower.layer, 0.6, 1, tower )
                else:
                    makeMons( 0, tower.layer, 0.6, 1, tower )
                    makeMons( 2, tower.layer, 0.4, 2, tower )
                    if tower.area == 2:
                        makeMons( 20, 22, 1, 3, tower )
            elif (self.stg==3):
                if tower.area == 0:
                    makeMons( 2, tower.layer, 0.8, 3, tower )
                    makeMons( 2, tower.layer, 0.6, 2, tower )
                elif tower.area >= 1:
                    makeMons( 0, tower.layer, 0.6, 1, tower )
                    makeMons( 2, tower.layer, 0.5, 2, tower )
                    makeMons( 2, tower.layer, 0.6, 3, tower )
                    if tower.area == 2:
                        makeMons( 20, 22, 1, 4, tower )
            elif (self.stg==4):
                if tower.area == 0:
                    makeMons( 0, tower.layer, 0.65, 1, tower )
                    makeMons( 2, tower.layer, 0.55, 2, tower )
                    #makeMons( 4, 6, 1, 4, tower )
                if tower.area >= 1:
                    makeMons( 0, tower.layer, 0.6, 1, tower )
                    makeMons( 2, tower.layer, 0.45, 2, tower )
                    makeMons( 4, tower.layer, 0.5, 3, tower )
            elif (self.stg==5):
                makeMons( 0, tower.layer, 0.7, 1, tower )
                makeMons( 2, tower.layer, 0.6, 2, tower )
                #makeMons( 6, 8, 1, 3, tower )
            elif (self.stg==6):
                makeMons( 0, tower.layer, 0.7, 1, tower )
                makeMons( 2, tower.layer, 0.7, 2, tower )
                if tower.area == 2:
                    makeMons( 20, 22, 1, 3, tower )
            elif (self.stg==7):
                makeMons( 0, tower.layer, 0.7, 1, tower )
            # ÈöèÊú∫ÊåáÂÆö‰ªªÊÑè‰∏™Âå∫ÂüüÂ∞ÅÈîÅËÄÖ
            i = 0
            for minion in tower.monsters:
                i += 1
                self.allElements.add(minion)
                if random()<0.1 or ( i==len(tower.monsters) and len(tower.goalieList)==0 ):
                    tower.goalieList.add( minion )

    def go(self, themeColor, horns, heroBook, stgManager, diffi):
        
        self.music.play(-1)
        self.screen.fill( (0, 0, 0) )
        self.screen.blit( self.towerBG, self.towerBGRect )
        if self.stg==2:
            c = enemy.Column(self.bg_size, self.tower.groupList)
            self.allElements.add(c)
        elif self.stg==3:
            mist = enemy.Mist(self.bg_size)
        elif self.stg==4:
            ooze = enemy.Ooze(self.bg_size, self.blockSize, self.fntSet[0][1]) # ‰∏≠Êñá
        elif self.stg==5:
            blizzard = enemy.blizzardGenerator(self.bg_size)
        for item in self.allElements:
            self.screen.blit( item.image, item.rect )
        while self.gameOn:
            if not self.paused: # Ëã•Êú™ pause.
                # respond to the player's ongoing keydown event.
                # get the list including the boolean status of all keys:
                key_pressed = pygame.key.get_pressed()
                for hero in self.heroes:
                    if hero.category == "follower":
                        continue
                    if key_pressed[ hero.keyDic["leftKey"] ]:
                        hero.moveX( self.delay, "left" )
                    elif key_pressed[ hero.keyDic["rightKey"] ]:
                        hero.moveX( self.delay, "right" )
                self.frontier = self.bg_size[1]
                self.frnLayer = 0
                for hero in self.heroes:
                    self.frontier = min(self.frontier, hero.rect.bottom)
                    self.frnLayer = max(self.frnLayer, hero.onlayer)
                
                # move all if the screen need to be adjusted.
                gap = ( self.bg_size[0] - (self.tower.boundaries[0]+self.tower.boundaries[1]) ) //2
                if gap:
                    lvl = min(gap, 10) if gap>0 else max(gap, -10)
                    for tower in self.areaList:
                        tower.level( lvl )
                    for elem in self.allElements:
                        elem.level( lvl )
                if ( self.tower.getTop(self.frnLayer) < self.bg_size[1]*0.42 ):
                    for elem in self.allElements:
                        elem.lift(self.scrnSpd)
                    for tower in self.areaList:
                        tower.lift(self.scrnSpd)
                    if self.stg==4:
                        ooze.lift(self.scrnSpd)
                elif ( self.tower.getTop(self.frnLayer)+self.blockSize > self.bg_size[1]*0.7 ) and ( self.tower.getTop(-1)+2*self.blockSize>=self.bg_size[1] ) :
                    for elem in self.allElements:
                        elem.lift(-self.scrnSpd)
                    for tower in self.areaList:
                        tower.lift(-self.scrnSpd)
                    if self.stg==4:
                        ooze.lift(-self.scrnSpd)
                
                # check hero's jump and fall:
                for hero in self.heroes:
                    # Ëã•Â§Ñ‰∫éË∑≥Ë∑ÉÁä∂ÊÄÅÔºåÂàôÊâßË°åË∑≥Ë∑ÉÂáΩÊï∞
                    if hero.k1 > 0:
                        hero.jump( self.tower.getTop(hero.onlayer+1) )
                    # Âê¶ÂàôÔºåÊâßË°åÊéâËêΩÂáΩÊï∞
                    else:
                        fallChecks = self.tower.groupList[str(hero.onlayer-1)]
                        if self.stg==2 and hero.rect.bottom <= (c.rect.top+2):   # Ëã±ÈõÑÁöÑ‰ΩçÁΩÆÊØîÁü≥Êü±È´òÊó∂ÔºåÂú®Ë∞ÉÁî®hero.fallËøõË°åÊéâËêΩÊ£ÄÊü•Êó∂Âä†ÂÖ•Áü≥Êü±ÔºåË∞ÉÁî®ÂÆåÊàêÂêé‰ºöËá™Âä®Ê∏ÖÈô§
                            hero.checkList.add( c )
                        hero.fall(self.tower.getTop(hero.onlayer-1), fallChecks, self.stg, self.tower.heightList)
                
                # repaint all elements
                self.screen.blit( self.towerBG, self.towerBGRect )
                for item in self.allElements:
                    self.moveMons( self, item, self.heroes )       # ÂàÜÂÖ≥Âç°Â§ÑÁêÜÊâÄÊúâÁöÑÊïå‰∫∫ÔºàËá™ÁÑ∂ÈòªÁ¢çÂíåÊÄ™ÂÖΩÔºâ„ÄÇÁî±‰∫éÊòØË¶ÜÁõñÁöÑÂáΩÊï∞ÔºåÈúÄË¶ÅÁªôselfÂèÇÊï∞„ÄÇ
                    if item.category=="sideWall" or item.category=="lineWall" or item.category=="baseWall" or item.category=="specialWall" or \
                        item.category == "supAmmo" or item.category == "fruit" or item.category == "torch" or item.category == "medicine":
                        item.paint(self.screen)
                    elif item.category == "lineDecor":
                        item.alter()
                        self.screen.blit(item.image, item.rect)
                    elif item.category == "hostage" or item.category == "door" or item.category == "notice" or item.category == "exit":
                        item.paint(self.screen, self.spurtCanvas, self.fntSet[0], self.language)
                    # Â§ÑÁêÜÊäïÊé∑Áâ©ÔºöÊäïÊé∑Áâ©ÁöÑmoveÂáΩÊï∞Â∞ÜËøîÂõû‰∏âÁßçÊÉÖÂÜµÔºö1.ËøîÂõûFalseÔºåË°®Á§∫Êú™ÂëΩ‰∏≠Ôºõ2.ËøîÂõûÂåÖÂê´‰∏§‰∏™ÂÖÉÁ¥†ÁöÑÂÖÉÁªÑÔºåÂê´‰πâÂàÜÂà´‰∏∫ÊäïÊé∑Áâ©ÁöÑÊñπÂêë‚Äúright‚ÄùÊàñ‚Äúleft‚ÄùÔºå‰ª•ÂèäÊäïÊé∑Áâ©Âáª‰∏≠ÁöÑÂùêÊ†áÔºàxÔºåyÔºâÔºõ
                    # 3.ËøîÂõûÂåÖÂê´‰∏â‰∏™ÂÖÉÁ¥†ÁöÑÂÖÉÁªÑÔºåÁ¨¨‰∏â‰∏™ÂÖÉÁªÑ‰∏∫Ê†áÂøóÂëΩ‰∏≠ÁõÆÊ†áÊòØÂê¶Ê≠ª‰∫°„ÄÇ
                    elif item.category=="bullet" or item.category=="bulletPlus":
                        arrCheck = self.tower.monsters
                        if self.stg==2:        # Á¨¨‰∫åÂÖ≥Âä†‰∏äÈöúÁ¢çÁâ©Â§ßÁü≥Â§¥„ÄÅËõõÁΩë
                            for elem in self.tower.elemList:
                                #if elem.category=="webWall" and not elem.valid:
                                #    continue
                                arrCheck.add(elem)
                        if item.category=="bullet":
                            item.move(arrCheck, self.spurtCanvas, self.bg_size)
                        else:
                            item.move(item, self.delay, arrCheck, self.spurtCanvas, self.bg_size) # ËøôÈáåËøòË¶Å‰º†ÂÖ•ÊäïÊé∑Áâ©Êú¨Ë∫´
                        self.screen.blit(item.image, item.rect)
                    elif item.category == "follower":
                        win = item.decideAction(self.delay, self.tower.heightList, self.tower.monsters, self.tower.porter)
                        if win:
                            self.music.stop()
                            self.gameOn = False
                            self.win = True
                            #return [True, self.heroes+self.tomb]         # win: return True and exp
                        drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
                        item.paint(self.screen)
                
                for hero in self.heroes:
                    # decide the image of Hero
                    hero.checkImg( self.delay, self.spurtCanvas, self.tower.monsters )
                    hero.paint( self.screen )
                    if len(hero.jmpInfo)>0:        # ÁªòÁîªË∑≥Ë∑ÉÁÉüÂ∞òÊïàÊûú
                        self.screen.blit( hero.jmpInfo[0], hero.jmpInfo[1] )
                    # ‰ªéheroÁöÑpreyList‰ø°ÊÅØÂàóË°®‰∏≠ÂèñÂáª‰∏≠‰ø°ÊÅØ„ÄÇ
                    for hitInfo in hero.preyList:
                        self.spurtCanvas.addSpatters( hitInfo[3], [2, 3, 4], [10, 11, 12], hitInfo[2], hitInfo[1] )
                        if hitInfo[4] and (hitInfo[4] in self.monsAcc):   # Âáª‰∏≠ÁöÑÁõÆÊ†áÊ≠ª‰∫°
                            self.spurtCanvas.addSouls( hitInfo[5], [5, 6], [15, 18, 20], (210,210,255,250), hitInfo[1], hero )
                            if self.monsAcc[ hitInfo[4] ].collec():       # Â∞ùËØïÊêúÈõÜËØ•ÊÄ™Áâ©„ÄÇËã•Â∑≤Êî∂ÈõÜÔºåÂàôËøîÂõûFalseÔºõÂê¶ÂàôÊî∂ÈõÜÊàêÂäüÔºåËøîÂõûTrue„ÄÇ
                                self.msgList.append( ["message", ("New monster collected to Collection!","Êñ∞ÁöÑÊÄ™Áâ©Â∑≤Êî∂ÈõÜËá≥ÂõæÈâ¥ÔºÅ"), 150, self.msgStick["msg"] ] )
                    hero.preyList = []  # ÊØèÊ¨°Âà∑Êñ∞ËØªÂèñÊâÄÊúâ‰ø°ÊÅØÂêéÔºåÂ∞ÜlistÈáçÁΩÆ‰∏∫Á©∫Ë°®
                    # ‰ªéheroÁöÑeventList‰∫ã‰ª∂ÂàóË°®‰∏≠Âèñ‰∫ã‰ª∂‰ø°ÊÅØÔºåÂπ∂Â∞Üthese newly opened chestsÂä†ÂÖ•self.subsList‰∏≠„ÄÇ
                    for item in hero.eventList:
                        if item=="exp":
                            self.msgList.append( [hero, item, 60] )
                        else:
                            self.msgList.append( [hero, item, 60] )
                            self.subsList.append(item)
                    hero.eventList = []

                # Á¨¨‰∏âÂÖ≥Â¢ûÂä†Ê∏∏ÊàèÈöæÂ∫¶ ---
                if ( self.stg==3 ):
                    sprites = [self.tower.porter]
                    for hero in self.heroes:
                        sprites.append(hero)
                    mist.renew( self.delay, sprites )
                    self.screen.blit( mist.canvas, mist.canvasRect )
                    if self.curArea >= 1:
                        mist.pervade = True
                    if not ( self.delay % 60 ):   # ÊØèÈöî‰∏ÄÊÆµÊó∂Èó¥Âú®Â±èÂπïËåÉÂõ¥ÂÜÖÁîüÊàê‰∏ÄÊ≥¢È™∑È´ÖÂÖµ
                        for line in range( self.frnLayer-3, self.frnLayer+3, 2 ):  # Ëµ∑ÁÇπÔºåÁªàÁÇπÔºåË∑®Â∫¶ÔºåÂèòheroÁöÑÂÅ∂Êï∞‰∏∫groupListÁöÑÂ•áÊï∞Ôºàhero.onlayer +- 4 - 1Ôºâ
                            if ( 0 < line < self.towerH-1 ) and len(self.tower.monsters) < 120 and ( random() < 0.1 ):
                                skeleton = enemy.Skeleton(self.tower.groupList[str(line)], self.blockSize, line)
                                self.tower.monsters.add(skeleton)
                                self.allElements.add(skeleton)
                elif (self.stg==4):
                    sprites = []
                    for hero in self.heroes:
                        sprites.append(hero)
                    for each in self.tower.monsters:
                        sprites.append(each)
                    ooze.rise( self.delay, self.screen, sprites, self.spurtCanvas )
                    if ( self.frnLayer>=30 ) and ( ooze.speed<=self.curArea+2 ):      # ÊØè‰∏™areaÁöÑÈÄüÂ∫¶‰∏äÈôêÔºåÂ¶Çarea0‰∏äÈôê‰∏∫2Ôºåarea1‰∏äÈôê‰∏∫3.
                        ooze.speed += 1
                        self.msgList.append( [ "message", ("The Ooze speeds up rising!","Ê≥•Ê≤º‰∏äÊ∂®ÈÄüÂ∫¶Âä†Âø´ÔºÅ"), 150, self.msgStick["msg"] ] )
                elif (self.stg==5):
                    blizzard.storm(self.heroes, self.nature.wind, self.spurtCanvas)
                
                if self.vibration > 0:
                    if (self.vibration % 2 == 0):
                        for elem in self.allElements:
                            elem.lift(4)
                            elem.level(4)
                    elif (self.vibration % 2 == 1):
                        for elem in self.allElements:
                            elem.lift(-4)
                            elem.level(-4)
                    self.vibration -= 1

                # ÁªòÂà∂‰∏âÂ±ÇÁîªÂ∏É
                if self.spurtCanvas:
                    self.spurtCanvas.update(self.screen)
                if self.haloCanvas:
                    self.haloCanvas.update( self.delay, self.screen )
                if self.nature:
                    self.nature.update(self.screen)
                # ÁõÆÊ†áÊÄ™Áâ©
                if self.delay <= 120:
                    for each in self.tower.goalieList:
                        self.addSymm( self.aimImg, enemy.getPos(each,0.5,0.5)[0]-480, enemy.getPos(each,0.5,0.5)[1]-360)
                # Âú®Ëø∑Èõæ/ÁîªÂ∏É‰πãÂêéÂÜçÁîªËé∑ÂæóÁöÑË°•ÁªôÂìÅÔºåÂê¶Âàô‰ºöË¢´Ëø∑Èõæ/ÁîªÂ∏ÉÁõñÊéâ
                for item in self.subsList:
                    if not item.reached:
                        item.subsMove()
                        self.screen.blit(item.substance, item.subsRect)
                    else:
                        self.subsList.remove(item)

                # draw hero status info
                for hero in self.heroes:
                    if hero.category == "follower":
                        continue
                    self.addSymm( hero.slot, hero.propPos["slot"][0], hero.propPos["slot"][1] )
                    self.addSymm( hero.brand, hero.propPos["slot"][0]-110, hero.propPos["slot"][1] )
                    self.addTXT( ("Level "+str(hero.lvl), "Á≠âÁ∫ß"+str(hero.lvl)), 0, (255,255,255), hero.propPos["slot"][0]-100, hero.propPos["slot"][1]+24 )
                    self.addSymm( hero.ammoImg, hero.propPos["ammo"][0], hero.propPos["ammo"][1] )
                    self.addTXT( (str(hero.arrow), str(hero.arrow)), 1, (255,255,255), hero.propPos["ammo"][0]+36, hero.propPos["ammo"][1] )
                    # ÁîªËÉåÂåÖÁâ©ÂìÅ
                    if len(self.effecter.SSList)==0:
                        if len(hero.bagBuf)>1:
                            nxtItem = hero.bagBuf[(hero.bagPt + 1) % len(hero.bagBuf)]
                            nxtRect = hero.bagImgList[nxtItem].get_rect()
                            nxtImg = pygame.transform.smoothscale(hero.bagImgList[nxtItem], ( int(nxtRect.width*0.7), int(nxtRect.height*0.7) ) )
                            nxtRect = self.addSymm( nxtImg, hero.propPos["bag"][0]-20, hero.propPos["bag"][1]+10 )
                        item = hero.bagBuf[hero.bagPt]
                        bagRect = self.addSymm( hero.bagImgList[item], hero.propPos["bag"][0], hero.propPos["bag"][1] )
                        self.addTXT( (str(hero.bag[item]),str(hero.bag[item])), 1, (255,255,255), hero.propPos["bag"][0]+36, hero.propPos["bag"][1] )
                    drawHealth( self.screen, hero.propPos["health"][0], hero.propPos["health"][1], 20, 18, hero.health, hero.full, 2 )
                
                pos = pygame.mouse.get_pos()
                bannerTuple = self.renderBanner(pos)
                self.showMsg(bannerTuple[2])   # Â∞ÜÁ¨¨3‰∏™sectionÔºàrectÔºâ‰º†ÈÄíÁªôshowMsgÂáΩÊï∞„ÄÇ
                menu = bannerTuple[3]

                # check big events.
                # Âõ†‰∏∫ÊúâÁöÑÊÄ™Áâ©ÔºàÂ¶ÇÊàà‰ªëÁü≥‰∫∫ÔºâÂ≠òÂú®Ê≠ª‰∫°Âª∂ËøüÔºåÊïÖÂú®ÊùÄÊ≠ªÊÄ™Áâ©ÁöÑÁû¨Èó¥Âà§Êñ≠‰ºö‰∏çÂáÜÁ°Æ„ÄÇÊïÖÊîæÂú®Â§ñÈù¢‰∏ÄÁõ¥‰æ¶Âê¨„ÄÇ
                if self.tower.area<=2 and len(self.tower.goalieList)==0 and self.tower.porter.locked: #ÔºàÈôê‰∫éÂâç‰∏â‰∏™Âå∫ÂüüÔºâ
                    self.tower.porter.unlock()
                    self.msgList.append( [ "message", ("The Area is unblocked!","Âå∫ÂüüÂ∞ÅÈîÅÂ∑≤Ëß£Èô§ÔºÅ"), 150, self.msgStick["msg"] ] )
                for hero in self.heroes:
                    if ( hero.rect.top >= self.bg_size[1] ):
                        hero.hitted(2, 0)
                    if ( hero.health <= 0 ):
                        self.heroes.remove(hero)
                        self.tomb.append(hero)
                        # Êúâ‰∏ÄÂêçËã±ÈõÑÊ≠ª‰∫°ÔºåÊ£ÄÊü•ÂÖ∂Ê≠ª‰∫°ÂêéheroesÂàóË°®‰∏≠ÁöÑËã±ÈõÑÊÉÖÂÜµ„ÄÇ
                        if hero.category=="follower":  # Â§±Ë¥•ÊÉÖÂÜµ1ÔºöË¶ÅËê•ÊïëÁöÑÂØπË±°Ê≠ª‰∫°
                            self.music.stop()
                            self.gameOn = False
                            self.win = False
                            return [False, self.heroes+self.tomb]
                        else:
                            if self.hostage:               # Â§±Ë¥•ÊÉÖÂÜµ2ÔºöÂΩìËê•ÊïëÂØπË±°Êú™Âä†ÂÖ•Êó∂ÔºåÊâÄÊúâÁé©ÂÆ∂Ê≠ª‰∫°
                                if (len(self.heroes)<=0):  # Ê≠ª‰∫°ÁöÑ‰∏çÊòØËê•ÊïëÂØπË±°Ôºå‰ΩÜÊâÄÊúâÁé©ÂÆ∂Ê≠ª‰∫°
                                    self.music.stop()
                                    self.gameOn = False
                                    self.win = False
                                    #return [False, self.heroes+self.tomb]         # died: return False
                            else:
                                if (len(self.heroes)<=1):  # Â§±Ë¥•ÊÉÖÂÜµ3ÔºöËê•ÊïëÂØπË±°Âú®ÈòüÂàó‰∏≠ÔºåÈô§ta‰ª•Â§ñÁöÑÊâÄÊúâÁé©ÂÆ∂Ê≠ª‰∫°
                                    self.music.stop()
                                    self.gameOn = False
                                    self.win = False
                                    #return [False, self.heroes+self.tomb]       # died: return False
                    # ËøõÂÖ•‰∏ã‰∏Ätower„ÄÇ
                    if hero.category == "follower":
                        continue
                    if hero.onlayer>=self.tower.layer and enemy.getPos(hero, 0.5, 0.5)[0]>self.tower.boundaries[1]+2*self.blockSize:
                        self.curArea += 1
                        self.tower = self.areaList[self.curArea]
                        hero.onlayer = 0
                        # Ëã•ËøõÂÖ•ÁöÑÊòØÊñ∞Âå∫ÂüüÔºåÂàôÂ∞ÜÂå∫ÂüüÂØπËØùÂä†ÂÖ•Ê∂àÊÅØÂàóË°®„ÄÇ
                        if self.curArea not in self.remindedArea:
                            self.remindedArea.append(self.curArea)
                            for msg in self.plotManager.getPre(self.curArea):
                                self.msgList.append( [ "message", msg, 150, self.msgStick["dlg"] ] )
                    # ËøîÂõû‰∏ä‰∏Ätower„ÄÇ
                    elif hero.onlayer<=0 and enemy.getPos(hero, 0.5, 0.5)[0]<self.tower.boundaries[0]-2*self.blockSize:
                        self.curArea -= 1
                        self.tower = self.areaList[self.curArea]
                        hero.onlayer = self.tower.layer
                
            else:                
                # ÈÄèÊòéÁÅ∞Ëâ≤ÊâìÂ∫ï
                if not self.setBG:
                    self.setBG = True
                    drawRect( 0, 0, self.bg_size[0], self.bg_size[1], (0,0,0,180), self.screen )
                    tip = choice( self.plotManager.tips )
                # Âä†Board to represent some tips.
                self.addSymm( pygame.image.load("image/cardBoard.png"), 0, 0 )
                self.addSymm( pygame.image.load("image/Enter.png").convert_alpha(), 0, -60 )
                self.addTXT( ["continue/pause","ÁªßÁª≠/ÊöÇÂÅú"], 0, (20,20,20), 0, -30)
                # tip area. 
                drawRect( self.bg_size[0]//2-240, self.bg_size[1]//2+20, 480, 100, (210,180,120,120), self.screen )
                topAlign = 50
                for line in tip:
                    self.addTXT( line, 0, (0,0,0), 0, topAlign )
                    topAlign += 20
                
                # handle controllers images and click events -----------------------------------
                home = self.addSymm( self.controller[0], -260, self.ctrY)
                BGMusic = self.addSymm( self.controller[1], -200, self.ctrY) if self.musicOn else self.addSymm( self.controller[2], -200, self.ctrY)
                pos = pygame.mouse.get_pos()
                if ( home.left < pos[0] < home.right ) and ( home.top < pos[1] < home.bottom ):  # ÈÄÄÂá∫ÔºàÊîæÂºÉÔºâÂΩìÂâçÂÖ≥Âç°
                    home = self.addSymm( self.controllerOn[0], -260, self.ctrY)
                    self.addTXT( ("quit","ÊîæÂºÉ"), 0, (60,60,60), -260, self.ctrY+40 )
                elif ( BGMusic.left < pos[0] < BGMusic.right ) and (BGMusic.top < pos[1] < BGMusic.bottom ):
                    if self.musicOn:
                        BGMusic = self.addSymm( self.controllerOn[1], -200, self.ctrY)
                        self.addTXT( ("music off","ÂÖ≥Èó≠Èü≥‰πê"), 0, (60,60,60), -200, self.ctrY+40 )
                    else:
                        BGMusic = self.addSymm( self.controllerOn[2], -200, self.ctrY)
                        self.addTXT( ("music on","ÂºÄÂêØÈü≥‰πê"), 0, (60,60,60), -200, self.ctrY+40 )
                    
            # ‰∏ÄÊ¨°ÊÄßÁöÑÈº†Ê†áÁÇπÂáªÊàñÊåâÈîÆ‰∫ã‰ª∂
            for event in pygame.event.get():
                if ( event.type == QUIT ):
                    pygame.quit()
                    sys.exit()
                elif ( event.type == KEYDOWN ):
                    if not self.paused:
                        for hero in self.heroes:
                            if hero.category == "follower":
                                continue
                            if ( event.key == hero.keyDic["wrestleKey"] ):    # Êå•ÂàÄ
                                if (hero.onlayer == 0) and self.hostage and ( pygame.sprite.collide_mask(hero, self.hostage) ):
                                    # Â∞ÜhostageÂèò‰∏∫‰∏Ä‰∏™heroÂπ∂Âä†ÂÖ•heroesÈòüÂàó„ÄÇ
                                    pos = (self.hostage.rect.left, self.hostage.rect.bottom)
                                    follower = myHero.Follower(self.bg_size, self.blockSize, self.hostage, hero, pos)
                                    for tower in self.areaList:
                                        for brick in tower.groupList["-1"]:
                                            follower.checkList.add( brick )
                                        for elem in tower.elemList:
                                            follower.checkList.add(elem)
                                    self.heroes.append(follower)
                                    self.allElements.add(follower)
                                    # Â∑≤ÁªèË¢´Â∏¶Ëµ∑ÔºåÂ∞ÜÂéüÊù•ÁöÑhostageÂà†Èô§„ÄÇ
                                    self.hostage.kill()
                                    self.hostage = None
                                else:
                                    hero.whip()
                            elif ( event.key == hero.keyDic["jumpKey"] ):   # Ë∑≥Ë∑É
                                if ( hero.k1 > 0 ) and ( hero.k2 == 0 ):
                                    hero.k2 = 1
                                if not hero.trapper and hero.aground and ( hero.k1 == 0 ):
                                    hero.k1 = 1
                            elif ( event.key == hero.keyDic["shootKey"] ) and hero.affected<0:    # Â∞ÑÁÆ≠
                                hero.shoot( self.allElements, self.delay )
                            elif ( event.key == hero.keyDic["itemKey"] ):    # ‰ΩøÁî®ËÉåÂåÖÁâ©ÂìÅ
                                hero.useItem( self.spurtCanvas )
                            elif ( event.key == hero.keyDic["downKey"] ):    # ‰∏ãË∑≥
                                hero.shiftLayer(-2, self.tower.heightList)
                            elif ( event.key == hero.keyDic["bagKey"] ) and len(self.effecter.SSList)==0 and len(hero.bagBuf)>1:     # ÂàáÊç¢ËÉåÂåÖÁâ©ÂìÅ
                                self.effecter.addSmoothSwitch(hero.bagImgList[item], bagRect, 0.7, -20, -10, 10)
                                self.effecter.addSmoothSwitch(nxtImg, nxtRect, 1.4, 20, -10, 10)
                                hero.bagPt = (hero.bagPt + 1) % len(hero.bagBuf)
                            # elif ( event.key == pygame.K_u ):              # ÁâπÊÆäÊäÄËÉΩ
                            #     self.hero.special()
                    if ( event.key == pygame.K_RETURN ):          # ÊöÇÂÅú/Ëß£Èô§ÊöÇÂÅú
                        self.paused = not self.paused
                        self.setBG = False # Áî®‰ª•ÊåáÁ§∫ÂèØ‰ª•Èì∫‰∏ÄÂ±ÇÈÄèÊòéËÉåÊôØ
                elif event.type == pygame.MOUSEBUTTONUP:          # Èº†Ê†á‰∫ã‰ª∂
                    if self.paused:
                        if ( home.left < pos[0] < home.right ) and ( home.top < pos[1] < home.bottom ):  # ÈÄÄÂá∫ÔºàÊîæÂºÉÔºâÂΩìÂâçÂÖ≥Âç°
                            self.music.stop()
                            self.gameOn = False
                            self.win = False
                            #return [False, self.heroes+self.tomb]
                        elif ( BGMusic.left < pos[0] < BGMusic.right ) and (BGMusic.top < pos[1] < BGMusic.bottom ):
                            if self.musicOn:
                                self.music.stop()
                                self.musicOn = False
                            else:
                                self.music.play(-1)
                                self.musicOn = True
                    else:
                        if ( menu.left < pos[0] < menu.right ) and ( menu.top < pos[1] < menu.bottom ):
                            self.paused = not self.paused

            pygame.display.flip()   # from buffer area load the pic to the screen
            self.delay -= 1
            if not self.delay:
                self.delay = 240
            self.clock.tick(60)
        
        # ===================================================================
        # Game Loop ÁªìÊùüÔºåÊ∏≤Êüì Stage Over ÁïåÈù¢„ÄÇ
        drawRect( 0, 0, self.bg_size[0], self.bg_size[1], themeColor, self.screen )
        # Êí≠ÊîæÈü≥Êïà„ÄÇ
        if self.win:
            horns[0].play(0)
            self.addTXT( ("Successful Rescue!","Ëê•ÊïëÊàêÂäüÔºÅ"), 3, (255,255,255), 0, -120)
            if self.stg<len(heroBook.accList) and not heroBook.accList[self.stg]:
                heroBook.accList[self.stg] = True    # ÂΩìÂâçÂÖ≥Âç°ÈÄöËøáÔºå‰∏ã‰∏ÄÂÖ≥ÁöÑËã±ÈõÑËßíËâ≤Ëß£ÈîÅ ‚úîherobook
                heroBook.heroList[self.stg].acc = True
                hName = heroBook.heroList[self.stg].name
                self.addTXT( ("New hero "+hName[0]+" is now accessible.","Êñ∞Ëã±ÈõÑ "+hName[1]+" Â∑≤Ëß£ÈîÅ„ÄÇ"), 1, (255,255,255), 0, -120)
            # ‰øÆÊîπÂÖ≥Âç°ÈÄöËøá‰ø°ÊÅØ
            line = plotManager.readFile( "r", 1, None )
            info = stgManager.renewRec( line, self.stg-1, diffi, 0 )
            plotManager.readFile( "w", 1, info)
        else:
            horns[1].play(0)
            self.addTXT( ("Mission Failed.","Ëê•ÊïëÂ§±Ë¥•„ÄÇ"), 3, (255,255,255), 0, -120)
        # ‰∏çËÆ∫ËÉúË¥ü‰∏éÂê¶ÔºåÈÉΩÊòæÁ§∫ÂèÇ‰∏éÊú¨ÂÖ≥ÁöÑËã±ÈõÑÁöÑÁªèÈ™åÂÄº‰ø°ÊÅØÔºåÂπ∂ËÆ°ÁÆóÁªèÈ™åÂÄºËé∑Âæó„ÄÇ
        y1 = 20
        for hero in (self.heroes + self.tomb):
            if not hero.category=="follower":
                heroBook.heroList[int(hero.heroNo)].increaseExp(hero.expInc)

                vHero = heroBook.heroList[hero.heroNo]  # ‰ªéheroBookÁöÑÂàóË°®‰∏≠ÂèñVHeroÁ±ªÂûã
                # brand of the hero.
                brd = self.addSymm(hero.brand, -120, y1)
                # level.
                bar = heroBook.drawExp( self.screen, brd.right+6, brd.bottom-26, int(vHero.exp), int(vHero.nxtLvl), 2 )
                expTXT = ( "Level"+str(vHero.lvl)+" (EXP+"+str(hero.expInc)+")","Á≠âÁ∫ß"+str(vHero.lvl)+"ÔºàÁªèÈ™å+"+str(hero.expInc)+"Ôºâ" )
                self.addTXT( expTXT, 1, (240,230,230), bar.left+bar.width//2-self.bg_size[0]//2, (bar.top-40)-self.bg_size[1]//2 )
                y1 += 90

        while True:
            # two Basic Buttons.
            restart = drawRect( self.bg_size[0]//2-220, 560, 200, 60, themeColor, self.screen )
            retreat = drawRect( self.bg_size[0]//2+20, 560, 200, 60, themeColor,self.screen )

            pos = pygame.mouse.get_pos()
            if ( restart.left < pos[0] < restart.right ) and ( restart.top < pos[1] < restart.bottom ):
                drawRect( restart.left+5, restart.top+5, restart.width-10, restart.height-10, (210,210,210,60), self.screen )
                if pygame.mouse.get_pressed()[0]:
                    horns[2].play(0)
                    return True  # ËøîÂõûTrueÔºåÂàômain‰∏≠ÁöÑÂæ™ÁéØÁªßÁª≠„ÄÇ
            elif ( retreat.left < pos[0] < retreat.right ) and ( retreat.top < pos[1] < retreat.bottom ):
                drawRect( retreat.left+5, retreat.top+5, retreat.width-10, retreat.height-10, (210,210,210,60), self.screen )
                if pygame.mouse.get_pressed()[0]:
                    horns[2].play(0)
                    return False # ËøîÂõûFalseÔºåÂàôÁªìÊùümain‰∏≠ÁöÑÂæ™ÁéØ„ÄÇ
            
            self.addTXT( ("Retry","ÈáçËØï"), 2, (255,255,255), -120, 230)
            self.addTXT( ("Home","‰∏ªËèúÂçï"), 2, (255,255,255), 120, 230)
            for event in pygame.event.get():  # ÂøÖ‰∏çÂèØÂ∞ëÁöÑÈÉ®ÂàÜÔºåÂê¶Âàô‰∫ã‰ª∂ÂìçÂ∫î‰ºöÂ¥©Ê∫É
                if ( event.type == QUIT ):
                    pygame.quit()
                    sys.exit()
                
            pygame.display.flip()   # from buffer area load the pic to the screen
            self.clock.tick(60)

    # ---- clear all elements in the model ----
    def clearAll(self):
        for each in self.allElements:
            each.kill()
            del each
        for tower in self.areaList:
            del tower

    # ---- show feedback of hero motion ----
    def showMsg(self, msgSect):
        vaccant = True
        for msg in self.msgList:
            if msg[2] == 0: # ÂÄíËÆ°Êó∂Âáè‰∏∫0Êó∂‰ªéÂàóË°®Âà†Èô§
                self.msgList.remove(msg)
                continue
            # Âà§Êñ≠Ê∂àÊÅØÁöÑÁ±ªÂûã„ÄÇÈ¶ñÂÖàÊ£ÄÊü•Á¨¨‰∏Ä‰∏™‰ø°ÊÅØÊòØÂê¶‰∏∫‚Äúmessage‚ÄùÔºåÊòØÂàôË¶ÅÂú®bannerÁöÑÊ∂àÊÅØÊ°Ü‰∏≠ÊòæÁ§∫„ÄÇ
            if msg[0]=="message":
                if vaccant:
                    ctr = (msgSect.left+msgSect.width//2-self.bg_size[0]//2, msgSect.top+msgSect.height//2-self.bg_size[1]//2 )
                    self.addSymm( msg[3], msgSect.left+30-self.bg_size[0]//2, ctr[1] )  # Ê∂àÊÅØÊ†èÂ∑¶‰æßÊòæÁ§∫Ê∂àÊÅØÂõæÊ†á„ÄÇ
                    self.addTXT( msg[1], 1, (255,255,255), ctr[0], ctr[1])
                    msg[2] -= 1
                    vaccant = False
            #Ëã•‰∏çÊòØmessageÂ≠óÊÆµÔºåÂàôË°®Á§∫ÊòØÂÆùÁÆ±Ëé∑ÂæóË°•ÁªôÁâ©ÂìÅÔºö
            else:
                if msg[1]=="exp":
                    txt = ( msg[0].itemDic[msg[1]][0]+ "+1", msg[0].itemDic[msg[1]][1]+ "+1" )
                else:
                    txt = ( msg[0].itemDic[msg[1].category][0]+ "+" + str(msg[1].contains), msg[0].itemDic[msg[1].category][1]+ "+" + str(msg[1].contains) )
                ctr = ( msg[0].rect.left+msg[0].rect.width//2-self.bg_size[0]//2, msg[0].rect.top-self.bg_size[1]//2-(60-msg[2]) )
                self.addTXT( txt, 0, (255,255,255), ctr[0], ctr[1])
                msg[2] -= 1      # Ê∂àÊÅØÊòæÁ§∫ÂÄíËÆ°Êó∂-1
    
    # --- paint upper banner (contains 4 sections) ---
    def renderBanner(self, pos):
        # paint 4 background sections and get their rect.
        sect1 = drawRect(20, 10, 60, 40, (0,0,0,120), self.screen)    # Goalie Information.
        sect2 = drawRect(100, 10, 80, 40, (0,0,0,120), self.screen)   # Area Number.
        sect3 = drawRect(200, 10, 660, 40, (0,0,0,120), self.screen)  # Message Bar.
        sect4 = drawRect(880, 10, 60, 40, (0,0,0,120), self.screen)   # Menu Option.
        # give banner info.
        ctr = (sect1.left+sect1.width//2-self.bg_size[0]//2, sect1.top+sect1.height//2-self.bg_size[1]//2)  # Êõ¥Êîπ‰∏∫‰∏≠ÂøÉÂùêÊ†áÁ≥ªÁªüÁöÑ‰∏≠ÂøÉÁÇπÂèÇÊï∞
        self.addSymm( pygame.image.load("image/goalie.png").convert_alpha(), ctr[0], ctr[1] )
        self.addTXT( ( str(len(self.tower.goalieList)), str(len(self.tower.goalieList)) ), 1, (255,255,255), ctr[0], ctr[1])

        ctr = (sect2.left+sect2.width//2-self.bg_size[0]//2, sect2.top+sect2.height//2-self.bg_size[1]//2)
        self.addTXT( ("Area%d" % (self.curArea+1), "Âå∫Âüü%d" % (self.curArea+1)), 1, (255,255,255), ctr[0], ctr[1] )

        ctr = (sect4.left+sect4.width//2-self.bg_size[0]//2, sect4.top+sect4.height//2-self.bg_size[1]//2)
        menu = self.addSymm( pygame.image.load("image/menu.png").convert_alpha(), ctr[0], ctr[1] )
        if ( menu.left < pos[0] < menu.right ) and ( menu.top < pos[1] < menu.bottom ):  # 
            menu = self.addSymm( pygame.image.load("image/menuOn.png").convert_alpha(), ctr[0], ctr[1] )
            self.addTXT( ("menu","ËèúÂçï"), 0, (255,255,255), ctr[0], ctr[1] )
        
        return (sect1, sect2, sect3, sect4)

    # ========================================================================
    # ================= Game Loop ÁªìÊùüÂêéÁöÑStageÊÄªÁªìÁïåÈù¢ =======================
    #def renderConclusion(self, heroBook):
    #    pass

    # ========================================================================
    # ================= Áî®‰∫éÊ£ÄÊµãitem‰∏∫Êïå‰∫∫ÁöÑÊÉÖÂÜµ‰∏ãÔºåÂπ∂ÁßªÂä®ËØ•Êïå‰∫∫ ================
    # Â∞ÜËøô‰∏ÄÈÉ®ÂàÜ‰ªégo()ÂàÜÁ¶ªÂá∫Êù•ÁöÑÁõÆÁöÑÊòØ‰∏çËÆ©‰∏ªÂáΩÊï∞ÊòæÂæóËøá‰∫éÂ∫ûÂ§ßÔºåÂçïÁã¨Êàê‰∏∫‰∏Ä‰∏™ËæÖÂä©ÂáΩÊï∞ÊúâÂä©‰∫é‰πãÂêéÁöÑÁª¥Êä§Âíå‰øÆÊîπ
    # ========================================================================
    def moveMons(self, item, heroes):
        # This function should be overlapped in the initial constrction according to the stage.
        pass

    # ===========================================
    # SurfaceÂØπË±°Ôºõ xÔºåy‰∏∫Ê≠£Ë¥üÔºàÂÅèÁ¶ªÂ±èÂπï‰∏≠ÂøÉÁÇπÔºâÂÉèÁ¥†ÂÄºÔºåÁ°ÆÂÆö‰∫ÜÂõæÂÉèÁöÑ‰∏≠ÁÇπÂùêÊ†á
    def addSymm(self, surface, x, y):
        rect = surface.get_rect()
        rect.left = (self.bg_size[0] - rect.width) // 2 + x
        rect.top = (self.bg_size[1] - rect.height) // 2 + y
        self.screen.blit( surface, rect )
        return rect   # ËøîÂõûÂõæÁâáÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØ‰ª•‰æõÊõ¥Â§öÊìç‰Ωú

    # ===========================================
    # x,y‰∏∫Ê≠£Ë¥üÔºàÂÅèÁ¶ªÂ±èÂπï‰∏≠ÂøÉÁÇπÔºâÂÉèÁ¥†ÂÄºÔºåyÂàôÁ°ÆÂÆö‰∫ÜÊñáÂ≠óË°åÁü©ÂΩ¢ÁöÑ‰∏≠ÁÇπÂùêÊ†áÔºàÂ±Ö‰∏≠ÂØπÈΩêÔºâ„ÄÇ
    # ËøôÊ†∑ÊîπÂä®ÊòØ‰∏∫‰∫ÜÂíåaddSymm()ÂáΩÊï∞‰øùÊåÅ‰∏Ä‰∏™Áõ∏ÂØπÁªü‰∏ÄÁöÑÁ≥ªÁªü„ÄÇ
    def addTXT(self, txtList, fntSize, color, x, y):
        txt = self.fntSet[fntSize][self.language].render( txtList[self.language], True, color )
        rect = txt.get_rect()
        rect.left = (self.bg_size[0] - rect.width) //2 + x
        rect.top = (self.bg_size[1] - rect.height) //2 + y
        self.screen.blit( txt, rect )
        return rect

# =============================================================================================================
# -------------------------------------------------------------------------------------------------------------
# ------------------------------------ stage running class ----------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# =============================================================================================================
class EndlessModel():
    
    allElements = None    # a big Group for all sprites in this stage
    bg_size = ()          # Â±èÂπïÁöÑÂÆΩÈ´òÔºà‰∫åÂÖÉÁªÑÔºâ
    towerD = 10
    blockSize = 72
    ctrY = -130           # Âè≥‰∏äËßíÊéß‰ª∂ÁöÑÊ∞¥Âπ≥ÂÅèÁßª‰ΩçÁΩÆÔºàÂÉèÁ¥†Ôºâ
    language = 0          # ÂàùÂßãÈªòËÆ§‰∏∫Ëã±ÊñáÔºåÂèØÂú®ÊûÑÈÄ†ÂáΩÊï∞‰∏≠ËÆæÂÆö
    fntSet = []

    stg = 1
    scrnSpd = 4           # Â±èÂπï‰∏ä‰∏ãÁßªÂä®ÁöÑÈÄüÂ∫¶ÔºåÂçï‰ΩçÂÉèÁ¥†
    delay = 120           # Âª∂Êó∂ÂèòÈáèÔºåÁî®‰∫éÂú®‰∏çÂΩ±ÂìçÊ∏∏ÊàèÊ≠£Â∏∏ËøêË°åÁöÑÊÉÖÂÜµ‰∏ãÁªôÂõæÁâáÂàáÊç¢Â¢ûÂä†Âª∂Ëøü
    msgList = []          # Áî®‰∫éÂ≠òÂÇ®Ê∂àÊÅØÁöÑÂàóË°®ÔºàÂàóË°®ÂåÖÂê´ÂàóË°®ÔºâÔºö[[incident, cntDown]]
    subsList = []
    vibration = 0         # Áî®‰∫éÈúáÂä®ÂÖ®Â±èÁöÑÂèÇÊï∞
    keyDic = []
    monsters = None

    hero = None
    tower = None
    screen = None         # ‰øùÂ≠òÂ±èÂπïÂØπË±°ÁöÑÂºïÁî®
    clock = None
    towerBG = None        # ÂΩìÂâçÂÖ≥Âç°ÁöÑËÉåÊôØjpg
    towerBGRect = None
    nature = None
    plotManager = None
    haloCanvas = None     # bossÂá∫Áé∞Êó∂ÁöÑÂÖ®Â±èÈò¥ÂΩ±ÁîªÂ∏É

    msgStick = None
    music = None          # bgm ÔºàSoundÂØπË±°Ôºâ
    controller = []       # Âè≥‰∏äËßíÊéß‰ª∂
    controllerOn = []
    paused = True
    musicOn = True
    setBG = False
    gameOn = True         # modelÂæ™ÁéØÊ†áÂøóÔºåÈªòËÆ§‰∏∫TrueÔºåplayerÁÇπÂáªÈÄÄÂá∫ÊàñgameoverÊó∂Âèò‰∏∫False
    monsBroc = [ (),      # monsÁîüÊàêÊâãÂÜåÔºöËÆ∞ÂΩïÊØè‰∏™stgÊúâÂì™‰∫õmonsÔºåÊØî‰æãÂàÜÂà´‰∏∫Â§öÂ∞ë.ÂΩìÂâçÊòØstg0Ôºå‰∏çËÆ∞ÂΩï‰ªª‰Ωï‰∏úË•ø„ÄÇ
        ( (1,0.8), (2,0.6) ),           # stg1
        ( (1,0.75), (2,0.55) ),
        ( (1,0.9), (2,0.7), (3,0.7) ),
        ( (1,0.8), (2,0.6), (3,0.5) ),  # stg4
        ( (1,0.85), (2,0.75) ),
        ( (1,0.85), (2,0.85) ),
        ( (1,0.7), (1, 0.4) ) ]

    def __init__(self, stg, keyDic, bg_size, screen, language, fntSet, musicObj, natON, VHero):
        
        self.allElements = pygame.sprite.Group()
        self.stg = stg
        self.screen = screen
        self.bg_size = bg_size
        self.language = language
        self.keyDic = keyDic
        self.fntSet = fntSet
        self.plotManager = plotManager.Dialogue(self.stg)
        self.msgStick = pygame.image.load("image/tip.png").convert_alpha()
        self.nature = None
        if natON:
            if self.stg == 1:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 8, 1)
            elif self.stg == 2:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 1, 0)
            elif self.stg == 3:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 8, 1)
            elif self.stg == 4 or self.stg == 7:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 18, 0)
            elif self.stg == 5:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 10, -1)
            elif self.stg == 6:
                self.nature = mapManager.Nature(self.bg_size, self.stg, 8, 1)
        self.spurtCanvas = mapManager.SpurtCanvas( self.bg_size)
        self.haloCanvas = mapManager.HaloCanvas( self.bg_size)
        self.effecter = plotManager.Controller( bg_size )
        # create the hero
        propPos = { "slot":(-300,290), "ammo":(-335,268), "bag":(-230,268), "health":(115,660) }
        initPos = (self.bg_size[0]//2, self.bg_size[1]-self.blockSize)
        self.hero = myHero.Hero(initPos, self.blockSize, VHero, propPos, 1)
        self.allElements.add(self.hero)
        self.hero.haloCanvas = self.haloCanvas
        # Select and overlap the moveMons() method.
        if self.stg == 1:
            self.moveMons = moveMonsStg1
        elif self.stg == 2:
            self.moveMons = moveMonsStg2
        elif self.stg == 3:
            self.moveMons = moveMonsStg3
        elif self.stg == 4:
            self.moveMons = moveMonsStg4
        elif self.stg == 5:
            self.moveMons = moveMonsStg5
        elif self.stg == 6:
            self.moveMons = moveMonsStg6
        elif self.stg == 7:
            self.moveMons = moveMonsStg7
        enemy.Monster.healthBonus = 1
        # create the map (note: for good influency of the screen, please no more than 240 layers)
        self.tower = mapManager.EndlessTower(bg_size, self.blockSize, self.towerD, stg)
        self.tower.generateIni(self.screen)
        for key in self.tower.groupList:
            for brick in self.tower.groupList[key]:
                self.allElements.add( brick )    # Âä†ÂÖ•walls
                if brick.category == "sideWall" or brick.category == "baseWall":
                    self.hero.checkList.add( brick )
        for sup in self.tower.chestList:
            self.allElements.add(sup)            # Âä†ÂÖ•supply
            self.hero.checkList.add(sup)
        for elem in self.tower.elemList:
            self.allElements.add(elem)
            self.hero.checkList.add(elem)
        # towerËÉåÊôØÂõæÁâá
        self.towerBG = pygame.image.load( "image/stg"+ str(stg) +"/towerBG.jpg" ).convert()
        self.towerBGRect = self.towerBG.get_rect()
        self.towerBGRect.left = (self.bg_size[0]-self.towerBGRect.width) // 2
        self.towerBGRect.top = (self.bg_size[1]-self.towerBGRect.height) // 2
        # Âè≥‰∏äËßíÁöÑÊéß‰ª∂ÂõæÁâá
        self.controller = [pygame.image.load("image/quit.png").convert_alpha(), pygame.image.load("image/BGMusic.png").convert_alpha(), pygame.image.load("image/mute.png").convert_alpha()]
        self.controllerOn = [pygame.image.load("image/quitOn.png").convert_alpha(), pygame.image.load("image/BGMusicOn.png").convert_alpha(), pygame.image.load("image/muteOn.png").convert_alpha(),]
        self.clock = pygame.time.Clock()
        self.music = musicObj

    def go(self, themeColor, horns, stgManager):
        self.music.play(-1)
        # create natural impediments and monsters
        if (self.stg==1):
            infernoFires = pygame.sprite.Group()
            for i in range(2):
                f = enemy.InfernoFire(self.bg_size)
                infernoFires.add(f)
                self.allElements.add(f)
            makeMons( 0, self.tower.curLayer, 0.65, 1, self.tower )
            makeMons( 60, self.tower.curLayer, 0.45, 2, self.tower )
        elif (self.stg==2):
            c = enemy.Column(self.bg_size, self.tower.groupList)
            self.allElements.add(c)
            makeMons( 0, self.tower.curLayer, 0.6, 1, self.tower )
            makeMons( 60, self.tower.curLayer, 0.4, 2, self.tower )
        elif (self.stg==3):
            mist = enemy.Mist(self.bg_size)
            makeMons( 0, self.tower.curLayer, 0.8, 1, self.tower )
            makeMons( 10, self.tower.curLayer, 0.6, 2, self.tower )
        elif (self.stg==4):
            ooze = enemy.Ooze(self.bg_size, self.blockSize//2, self.fntSet[0][1]) # ‰∏≠Êñá
            #self.allElements.add(ooze)
            makeMons( 0, self.tower.curLayer, 0.65, 1, self.tower )
            makeMons( 2, self.tower.curLayer, 0.55, 2, self.tower )
        elif (self.stg==5):
            blizzard = enemy.blizzardGenerator(self.bg_size)
            makeMons( 0, self.tower.curLayer, 0.7, 1, self.tower )
            makeMons( 12, self.tower.curLayer, 0.6, 2, self.tower )
        elif (self.stg==6):
            makeMons( 0, self.tower.curLayer, 0.7, 1, self.tower )
            makeMons( 2, self.tower.curLayer, 0.7, 2, self.tower )
        elif (self.stg==7):
            makeMons( 0, self.tower.curLayer, 0.7, 1, self.tower )
        for minion in self.tower.monsters:
            self.allElements.add(minion)
        self.screen.fill( (0, 0, 0) )
        self.screen.blit( self.towerBG, self.towerBGRect )
        for item in self.allElements:
            self.screen.blit( item.image, item.rect )

        while self.gameOn:

            if not self.paused: # Ëã•Êú™ÊöÇÂÅú
                # respond to the player's ongoing keydown event
                # get the list including the boolean status of all keys:
                key_pressed = pygame.key.get_pressed()
                if key_pressed[ self.keyDic["leftKey"] ]:
                    self.hero.moveX( self.delay, "left" )
                elif key_pressed[ self.keyDic["rightKey"] ]:
                    self.hero.moveX( self.delay, "right" )

                # move all if the screen need to be adjusted
                if ( self.tower.getTop(self.hero.onlayer) < self.bg_size[1]*0.45 ):
                    for elem in self.allElements:
                        elem.lift(self.scrnSpd)
                    for each in self.tower.heightList:
                        self.tower.heightList[each] += self.scrnSpd
                    if self.stg==4:
                        ooze.lift(self.scrnSpd)
                    
                # check if it's needed to add More Layers
                if ( self.hero.onlayer >= (self.tower.curLayer-10) ):
                    self.tower.addMore()
                    # Ê∑ªÂä†Ëá≥allElements
                    for key in self.tower.groupList:
                        for brick in self.tower.groupList[key]:
                            if not brick in self.allElements:
                                self.allElements.add( brick )
                                if brick.category == "sideWall" or brick.category == "baseWall":
                                    self.hero.checkList.add( brick )
                    for sup in self.tower.chestList:
                        if not sup in self.allElements:
                            self.allElements.add(sup)
                            self.hero.checkList.add(sup)
                    for elem in self.tower.elemList:
                        if not elem in self.allElements:
                            self.allElements.add(elem)
                            self.hero.checkList.add(elem)
                    # Â¢ûÂä†Êñ∞Â±ÇÁöÑÊÄ™Áâ©
                    for each in self.monsBroc[self.stg]:
                        makeMons( self.tower.curLayer-10, self.tower.curLayer, each[1], each[0], self.tower )
                    for mons in self.tower.monsters:
                        if mons not in self.allElements:
                            self.allElements.add(mons)
                    # Âà†Èô§‰ΩéÂ±ÇÁöÑÊÄ™Áâ©(ËøôÈáå‰∏çÂ•Ω‰∏•Ê†ºÁî®layerÊù•Êìç‰ΩúÔºåÂõ†‰∏∫È£ûË°åÁöÑmonsterÊ≤°ÊúâÁâπÂÆöÁöÑonlayer„ÄÇÂõ†Ê≠§Áî®Â±èÂπïÁöÑÈ´òÂ∫¶‰∏∫Âà§Êñ≠ËåÉÂõ¥ÔºåË∂ÖÂá∫‰∏§ÂÄçÂàôÂà§ÂÆöÂà†Èô§)
                    for mons in self.tower.monsters:
                        if mons.rect.top >= 2*self.bg_size[1]:
                            mons.erase()
                
                # check jump and fall:
                if self.hero.k1 > 0:
                    self.hero.jump( self.tower.getTop( self.hero.onlayer+1 ) )
                else:
                    fallChecks = self.tower.groupList[str(self.hero.onlayer-1)]
                    if self.stg==2 and self.hero.rect.bottom < (c.rect.top+2):
                        self.hero.checkList.add( c )
                    self.hero.fall(self.tower.getTop(self.hero.onlayer-1), fallChecks, self.stg, self.tower.heightList)

                # repaint all elements
                self.screen.blit( self.towerBG, self.towerBGRect )
                for item in self.allElements:
                    self.moveMons( self, item, [self.hero] )
                    if item.category == "sideWall" or item.category == "lineWall" or item.category == "baseWall" or item.category == "specialWall" or \
                        item.category == "supAmmo" or item.category == "fruit" or item.category == "torch" or item.category == "medicine":
                        item.paint(self.screen)
                    elif item.category == "lineDecor":
                        item.alter()
                        self.screen.blit(item.image, item.rect)
                    elif item.category=="bullet" or item.category=="bulletPlus":
                        arrCheck = self.tower.monsters
                        if self.stg==2:
                            for elem in self.tower.elemList:
                                arrCheck.add(elem)
                        if item.category == "bullet":
                            item.move(arrCheck, self.spurtCanvas, self.bg_size)
                        else:
                            item.move(item, self.delay, arrCheck, self.spurtCanvas, self.bg_size) # ËøôÈáåËøòË¶Å‰º†ÂÖ•ÊäïÊé∑Áâ©Êú¨Ë∫´
                        self.screen.blit(item.image, item.rect)

                # decide the image of Hero
                self.hero.checkImg( self.delay, self.spurtCanvas, self.tower.monsters )
                self.hero.paint( self.screen )
                if len(self.hero.jmpInfo)>0:       # ÁªòÁîªË∑≥Ë∑ÉÁÉüÂ∞òÊïàÊûú
                    self.screen.blit( self.hero.jmpInfo[0], self.hero.jmpInfo[1] )
                # Fetch hitInfo from hero's preyList.
                for hitInfo in self.hero.preyList:
                    self.spurtCanvas.addSpatters(hitInfo[3], [2, 3, 4], [10, 11, 12], hitInfo[2], hitInfo[1])
                self.hero.preyList = []
                # ‰ªéheroÁöÑeventList‰∫ã‰ª∂ÂàóË°®‰∏≠Âèñ‰∫ã‰ª∂‰ø°ÊÅØ„ÄÇ
                for item in self.hero.eventList:
                    self.msgList.append( [item, 60] )
                    self.subsList.append(item)
                self.hero.eventList = [] 
                
                # ÂàÜÂÖ≥Âç°Â¢ûÂä†Ê∏∏ÊàèÈöæÂ∫¶ ---
                if ( self.stg==1 ):
                    if ( self.hero.onlayer >= 40 and len(infernoFires) < 3 ) or ( self.hero.onlayer >= 80 and len(infernoFires) < 4 ) or ( self.hero.onlayer >= 120 and len(infernoFires) < 5 ):
                        f = enemy.InfernoFire( self.bg_size )
                        infernoFires.add(f)
                        self.allElements.add(f)
                elif ( self.stg==3 ):
                    mist.renew( self.delay, [self.hero] )
                    self.screen.blit( mist.canvas, mist.canvasRect )
                    if (self.hero.onlayer >= 20):
                        mist.pervade = True
                    if not ( self.delay % 60 ):  # ÊØèÈöî‰∏ÄÊÆµÊó∂Èó¥Âú®Â±èÂπïËåÉÂõ¥ÂÜÖÁîüÊàê‰∏ÄÊ≥¢È™∑È´ÖÂÖµ
                        #self.msgList.append( [("Skeletons popping out!","È™∑È´ÖÂÖµÊ≠£Âú®Ê¥ªÂä®ÔºÅ"), 150] )
                        for line in range( self.hero.onlayer-3, self.hero.onlayer+3, 2 ): # Ëµ∑ÁÇπÔºåÁªàÁÇπÔºåË∑®Â∫¶ÔºåÂèòheroÁöÑÂÅ∂Êï∞‰∏∫groupListÁöÑÂ•áÊï∞Ôºàhero.onlayer +- 4 - 1Ôºâ
                            if ( line > 0 ) and len(self.tower.monsters) < 120 and ( random() < 0.1 ):
                                skeleton = enemy.Skeleton(self.tower.groupList[str(line)], self.blockSize, line)
                                self.tower.monsters.add(skeleton)
                                self.allElements.add(skeleton)
                elif ( self.stg==4 ):
                    sprites = [self.hero]
                    for each in self.tower.monsters:
                        sprites.append(each)
                    ooze.rise( self.delay, self.screen, sprites, self.spurtCanvas )
                    if ( self.hero.maxLayer>=10 and ooze.speed<=1 ) or ( self.hero.maxLayer>=60 and ooze.speed<=2 ) or ( self.hero.maxLayer>=150 and ooze.speed<=3 ) or ( self.hero.maxLayer>=240 and ooze.speed<=4 ):
                        ooze.speed += 1
                        self.msgList.append( [("The Ooze speeds up rising!","Ê≥•Ê≤º‰∏äÊ∂®ÈÄüÂ∫¶Âä†Âø´ÔºÅ"), 150] )
                elif ( self.stg==5 ):
                    blizzard.storm([self.hero], self.nature.wind, self.spurtCanvas)
                
                if self.vibration > 0:
                    if (self.vibration % 2 == 0):
                        for elem in self.allElements:
                            elem.lift(4)
                            elem.level(4)
                    elif (self.vibration % 2 == 1):
                        for elem in self.allElements:
                            elem.lift(-4)
                            elem.level(-4)
                    self.vibration -= 1

                # ÁªòÂà∂‰∏§Â±ÇÁîªÂ∏É
                if self.haloCanvas:
                    self.haloCanvas.update( self.delay, self.screen )
                if self.spurtCanvas and not self.paused:
                    self.spurtCanvas.update(self.screen)
                if self.nature and not self.paused:
                    self.nature.update(self.screen)
                 # Âú®Ëø∑Èõæ‰πãÂêéÂÜçÁîª‰∏ÄÈÅçÔºåÂê¶Âàô‰ºöË¢´Ëø∑ÈõæÁõñÊéâ
                for item in self.subsList:
                    if not item.reached:
                        item.subsMove()
                        self.screen.blit(item.substance, item.subsRect)
                    else:
                        self.subsList.remove(item)
                
                # draw hero status info
                self.addSymm( self.hero.slot, self.hero.propPos["slot"][0], self.hero.propPos["slot"][1] )
                self.addSymm( self.hero.brand, self.hero.propPos["slot"][0]-110, self.hero.propPos["slot"][1] )
                self.addTXT( ("Level "+str(self.hero.lvl), "Á≠âÁ∫ß"+str(self.hero.lvl)), 0, (255,255,255), self.hero.propPos["slot"][0]-100, self.hero.propPos["slot"][1]+24 )
                self.addSymm( self.hero.ammoImg, self.hero.propPos["ammo"][0], self.hero.propPos["ammo"][1] )
                self.addTXT( (str(self.hero.arrow), str(self.hero.arrow)), 1, (255,255,255), self.hero.propPos["ammo"][0]+36, self.hero.propPos["ammo"][1] )
                # Áîª bag item.
                if len(self.effecter.SSList)==0:
                    if len(self.hero.bagBuf)>1:
                        nxtItem = self.hero.bagBuf[(self.hero.bagPt + 1) % len(self.hero.bagBuf)]
                        nxtRect = self.hero.bagImgList[nxtItem].get_rect()
                        nxtImg = pygame.transform.smoothscale(self.hero.bagImgList[nxtItem], ( int(nxtRect.width*0.7), int(nxtRect.height*0.7) ) )
                        nxtRect = self.addSymm( nxtImg, self.hero.propPos["bag"][0]-20, self.hero.propPos["bag"][1]+10 )
                    item = self.hero.bagBuf[self.hero.bagPt]
                    bagRect = self.addSymm( self.hero.bagImgList[item], self.hero.propPos["bag"][0], self.hero.propPos["bag"][1] )
                    self.addTXT( (str(self.hero.bag[item]),str(self.hero.bag[item])), 1, (255,255,255), self.hero.propPos["bag"][0]+36, self.hero.propPos["bag"][1] )
                self.effecter.doSwitch(self.screen)
                drawHealth( self.screen, self.hero.propPos["health"][0], self.hero.propPos["health"][1], 20, 18, self.hero.health, self.hero.full, 2 )

                pos = pygame.mouse.get_pos()
                bannerList = self.renderBanner(pos)
                self.showMsg( bannerList[1] )
                menu = bannerList[2]

                # check collide.
                if ( self.hero.rect.top >= self.bg_size[1] ):
                    self.hero.hitted(2, 0)
                if ( self.hero.health <= 0 ):
                    self.music.stop()
                    self.gameOn = False

            else:   # ÊöÇÂÅúÁä∂ÊÄÅ
                # ÈÄèÊòéÁÅ∞Ëâ≤ÊâìÂ∫ï
                if not self.setBG:
                    self.setBG = True
                    drawRect( 0, 0, self.bg_size[0], self.bg_size[1], (0,0,0,180), self.screen )
                    tip = choice( self.plotManager.tips )
                # Âä†Board to represent some tips.
                self.addSymm( pygame.image.load("image/cardBoard.png"), 0, 0 )
                self.addSymm( pygame.image.load("image/Enter.png").convert_alpha(), 0, -60 )
                self.addTXT( ["continue/pause","ÁªßÁª≠/ÊöÇÂÅú"], 0, (20,20,20), 0, -30)
                # tip area. 
                drawRect( self.bg_size[0]//2-240, self.bg_size[1]//2+20, 480, 100, (210,180,120,120), self.screen )
                topAlign = 50
                for line in tip:
                    self.addTXT( line, 0, (0,0,0), 0, topAlign )
                    topAlign += 20
                
                # handle controllers images and click events -----------------------------------
                home = self.addSymm( self.controller[0], -260, self.ctrY)
                BGMusic = self.addSymm( self.controller[1], -200, self.ctrY) if self.musicOn else self.addSymm( self.controller[2], -200, self.ctrY)
                pos = pygame.mouse.get_pos()
                if ( home.left < pos[0] < home.right ) and ( home.top < pos[1] < home.bottom ):  # ÈÄÄÂá∫ÔºàÊîæÂºÉÔºâÂΩìÂâçÂÖ≥Âç°
                    home = self.addSymm( self.controllerOn[0], -260, self.ctrY)
                    self.addTXT( ("quit","ÊîæÂºÉ"), 0, (60,60,60), -260, self.ctrY+40 )

                elif ( BGMusic.left < pos[0] < BGMusic.right ) and (BGMusic.top < pos[1] < BGMusic.bottom ):
                    if self.musicOn:
                        BGMusic = self.addSymm( self.controllerOn[1], -200, self.ctrY)
                        self.addTXT( ("music off","ÂÖ≥Èó≠Èü≥‰πê"), 0, (60,60,60), -200, self.ctrY+40 )
                    else:
                        BGMusic = self.addSymm( self.controllerOn[2], -200, self.ctrY)
                        self.addTXT( ("music on","ÂºÄÂêØÈü≥‰πê"), 0, (60,60,60), -200, self.ctrY+40 )

            # ‰∏ÄÊ¨°ÊÄßÁöÑÈº†Ê†áÁÇπÂáªÊàñÊåâÈîÆ‰∫ã‰ª∂
            for event in pygame.event.get():
                if ( event.type == QUIT ):
                    pygame.quit()
                    sys.exit()
                elif ( event.type == KEYDOWN ):
                    if not self.paused:
                        if ( event.key == self.keyDic["wrestleKey"] ):   #Êå•ÂàÄ
                            self.hero.whip()
                        elif ( event.key == self.keyDic["jumpKey"] ):    #Ë∑≥Ë∑É
                            if ( self.hero.k1 > 0 ) and ( self.hero.k2 == 0 ):
                                self.hero.k2 = 1
                            if not self.hero.trapper and (self.hero.aground) and ( self.hero.k1 == 0 ):
                                self.hero.k1 = 1
                        elif ( event.key == self.keyDic["shootKey"] ) and self.hero.affected<0:    #Â∞ÑÁÆ≠
                            self.hero.shoot( self.allElements, self.delay )
                        elif ( event.key == self.keyDic["itemKey"] ):    #‰ΩøÁî®ËÉåÂåÖÁâ©ÂìÅ
                            self.hero.useItem( self.spurtCanvas )
                        elif ( event.key == self.keyDic["downKey"] ):    #‰∏ãË∑≥
                            self.hero.shiftLayer(-2, self.tower.heightList)
                        elif ( event.key == self.keyDic["bagKey"] )and len(self.effecter.SSList)==0 and len(self.hero.bagBuf)>1:     # ÂàáÊç¢ËÉåÂåÖÁâ©ÂìÅ
                            self.effecter.addSmoothSwitch(self.hero.bagImgList[item], bagRect, 0.7, -20, -10, 10)
                            self.effecter.addSmoothSwitch(nxtImg, nxtRect, 1.4, 20, -10, 10)
                            self.hero.bagPt = (self.hero.bagPt + 1) % len(self.hero.bagBuf)
                    #    elif ( event.key == pygame.K_u ):               #ÁâπÊÆäÊäÄËÉΩ
                    #        self.hero.special()
                    if ( event.key == pygame.K_RETURN ):            # ÊöÇÂÅú/Ëß£Èô§ÊöÇÂÅú
                        self.paused = not self.paused
                        self.setBG = False # Áî®‰ª•ÊåáÁ§∫ÂèØ‰ª•Èì∫‰∏ÄÂ±ÇÈÄèÊòéËÉåÊôØ
                elif event.type == pygame.MOUSEBUTTONUP:            # Èº†Ê†á‰∫ã‰ª∂
                    if self.paused:
                        if ( home.left < pos[0] < home.right ) and ( home.top < pos[1] < home.bottom ):  # ÈÄÄÂá∫ÔºàÊîæÂºÉÔºâÂΩìÂâçstg.
                            self.music.stop()
                            self.gameOn = False
                        elif ( BGMusic.left < pos[0] < BGMusic.right ) and (BGMusic.top < pos[1] < BGMusic.bottom ):
                            if self.musicOn:
                                self.music.stop()
                                self.musicOn = False
                            else:
                                self.music.play(-1)
                                self.musicOn = True
                    else:
                        if ( menu.left < pos[0] < menu.right ) and ( menu.top < pos[1] < menu.bottom ):
                            self.paused = not self.paused
            
            pygame.display.flip()   # from buffer area load the pic to the screen
            self.delay -= 1
            if not self.delay:
                self.delay = 240
            self.clock.tick(60)
        
        # ===================================================================
        # Game Loop ÁªìÊùüÔºåÊ∏≤Êüì Stage Over ÁïåÈù¢„ÄÇ
        drawRect( 0, 0, self.bg_size[0], self.bg_size[1], themeColor, self.screen )
        if ( self.hero.score > stgManager.high[self.stg-1] ):
            horns[0].play(0)
            self.addTXT( ("New highest!","Êñ∞ÁöÑÊúÄÈ´òÁ∫™ÂΩïÔºÅ"), 3, (255,255,255), 0, -240)
            line = plotManager.readFile( "r", 1, None )
            info = stgManager.renewRec( line, self.stg-1, self.hero.score, 1 )
            plotManager.readFile( "w", 1, info)
        self.addTXT( ("Previous best: %d" % stgManager.high[self.stg-1],"ÂéÜÂè≤ÊúÄ‰Ω≥Ôºö%d" % stgManager.high[self.stg-1]), 1, (255,255,255), 0, -120)
        self.addTXT( ("Your score: %d" % self.hero.score,"Êú¨Ê¨°ÂæóÂàÜÔºö%d" % self.hero.score), 3, (255,255,255), 0, -160)

        while True:
            # two Basic Buttons.
            restart = drawRect( self.bg_size[0]//2-220, 560, 200, 60, themeColor, self.screen )
            retreat = drawRect( self.bg_size[0]//2+20, 560, 200, 60, themeColor, self.screen )

            pos = pygame.mouse.get_pos()
            if ( restart.left < pos[0] < restart.right ) and ( restart.top < pos[1] < restart.bottom ):
                drawRect( restart.left+5, restart.top+5, restart.width-10, restart.height-10, (210,210,210,60), self.screen )
                if pygame.mouse.get_pressed()[0]:
                    horns[2].play(0)
                    return True
            elif ( retreat.left < pos[0] < retreat.right ) and ( retreat.top < pos[1] < retreat.bottom ):
                drawRect( retreat.left+5, retreat.top+5, retreat.width-10, retreat.height-10, (210,210,210,60), self.screen )
                if pygame.mouse.get_pressed()[0]:
                    horns[2].play(0)
                    return False
            
            self.addTXT( ("Retry","ÈáçËØï"), 2, (255,255,255), -120, 230)
            self.addTXT( ("Home","‰∏ªËèúÂçï"), 2, (255,255,255), 120, 230)
            for event in pygame.event.get():  # ÂøÖ‰∏çÂèØÂ∞ëÁöÑÈÉ®ÂàÜÔºåÂê¶Âàô‰∫ã‰ª∂ÂìçÂ∫î‰ºöÂ¥©Ê∫É
                if ( event.type == QUIT ):
                    pygame.quit()
                    sys.exit()
                
            pygame.display.flip()   # from buffer area load the pic to the screen
            self.clock.tick(60)

    # ---- clear all elements in the current stg ---
    def clearAll(self):
        for each in self.allElements:
            each.kill()
            del each
        self.hero.checkList.empty()

    # ---- show feedback of hero motion ----
    def showMsg(self, msgSect):
        vaccant = True
        for msg in self.msgList:
            if msg[1] == 0: # ÂÄíËÆ°Êó∂Âáè‰∏∫0Êó∂‰ªéÂàóË°®Âà†Èô§
                self.msgList.remove(msg)
                continue
            # Âà§Êñ≠Ê∂àÊÅØÁöÑÁ±ªÂûã„ÄÇÈ¶ñÂÖàÊ£ÄÊü•Á¨¨‰∏Ä‰∏™‰ø°ÊÅØÊòØÂê¶‰∏∫‚Äúmessage‚ÄùÔºåÊòØÂàôË¶ÅÂú®bannerÁöÑÊ∂àÊÅØÊ°Ü‰∏≠ÊòæÁ§∫„ÄÇ
            if type(msg[0]).__name__=="tuple":
                if vaccant:
                    ctr = (msgSect.left+msgSect.width//2-self.bg_size[0]//2, msgSect.top+msgSect.height//2-self.bg_size[1]//2 )
                    self.addSymm( self.msgStick, msgSect.left+30-self.bg_size[0]//2, ctr[1] )  # Ê∂àÊÅØÊ†èÂ∑¶‰æßÊòæÁ§∫Ê∂àÊÅØÂõæÊ†á„ÄÇ
                    self.addTXT( msg[0], 1, (255,255,255), ctr[0], ctr[1] )
                    vaccant = False
                    msg[1] -= 1
            # Ëã•‰∏çÊòØmessageÂ≠óÊÆµÔºåÂàôË°®Á§∫ÊòØÂÆùÁÆ±Ëé∑ÂæóË°•ÁªôÁâ©ÂìÅÔºö
            else:
                txt = ( self.hero.itemDic[msg[0].category][0]+ "+" + str(msg[0].contains), self.hero.itemDic[msg[0].category][1]+ "+" + str(msg[0].contains) )
                ctr = ( self.hero.rect.left+self.hero.rect.width//2-self.bg_size[0]//2, self.hero.rect.top-self.bg_size[1]//2-(60-msg[1]) )
                self.addTXT( txt, 0, (255,255,255), ctr[0], ctr[1] )
                msg[1] -= 1      # Ê∂àÊÅØÊòæÁ§∫ÂÄíËÆ°Êó∂-1

    # --- paint upper banner (contains 3 sections) ---
    def renderBanner(self, pos):
        # paint 4 background sections and get their rect.
        sect1 = drawRect(20, 10, 180, 40, (0,0,0,120), self.screen)   # Score Information.
        sect2 = drawRect(220, 10, 640, 40, (0,0,0,120), self.screen)  # Message Bar.
        sect3 = drawRect(880, 10, 60, 40, (0,0,0,120), self.screen)   # Menu Option.
        # give banner info.
        ctr = (sect1.left+sect1.width//2-self.bg_size[0]//2, sect1.top+sect1.height//2-self.bg_size[1]//2)  # Êõ¥Êîπ‰∏∫‰∏≠ÂøÉÂùêÊ†áÁ≥ªÁªüÁöÑ‰∏≠ÂøÉÁÇπÂèÇÊï∞
        self.addTXT(("Your score: %d" % self.hero.score,"‰Ω†ÁöÑÂæóÂàÜÔºö%d" % self.hero.score), 1, (255,255,255), ctr[0], ctr[1])

        ctr = (sect3.left+sect3.width//2-self.bg_size[0]//2, sect3.top+sect3.height//2-self.bg_size[1]//2)
        menu = self.addSymm( pygame.image.load("image/menu.png").convert_alpha(), ctr[0], ctr[1] )
        if ( menu.left < pos[0] < menu.right ) and ( menu.top < pos[1] < menu.bottom ):
            menu = self.addSymm( pygame.image.load("image/menuOn.png").convert_alpha(), ctr[0], ctr[1] )
            self.addTXT( ("menu","ËèúÂçï"), 0, (255,255,255), ctr[0], ctr[1] )
        
        return (sect1, sect2, sect3)
        
    # ==========================================================
    def moveMons(self, item, heroes):
        pass
        
    # ================================================================================
    # SurfaceÂØπË±°Ôºõ xÔºåy‰∏∫Ê≠£Ë¥üÔºàÂÅèÁ¶ª‰∏≠ÂøÉÁÇπÔºâÂÉèÁ¥†ÂÄº
    def addSymm(self, surface, x, y):
        rect = surface.get_rect()
        rect.left = (self.bg_size[0] - rect.width) // 2 + x
        rect.top = (self.bg_size[1] - rect.height) // 2 + y
        self.screen.blit( surface, rect )
        return rect   # ËøîÂõûÂõæÁâáÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØ‰ª•‰æõÊõ¥Â§öÊìç‰Ωú

    # ==========================================
    # x,y‰∏∫Ê≠£Ë¥üÔºàÂÅèÁ¶ªÂ±èÂπï‰∏≠ÂøÉÁÇπÔºâÂÉèÁ¥†ÂÄºÔºåÁ°ÆÂÆö‰∫ÜÊñáÂ≠óË°åÁöÑÂ∑¶‰∏äËßíÂùêÊ†á„ÄÇËøôÊ†∑ÊîπÂä®ÊòØ‰∏∫‰∫ÜÂíåaddSymm()ÂáΩÊï∞‰øùÊåÅ‰∏Ä‰∏™Áõ∏ÂØπÁªü‰∏ÄÁöÑÁ≥ªÁªü„ÄÇ
    def addTXT(self, txtList, fntSize, color, x, y):
        txt = self.fntSet[fntSize][self.language].render( txtList[self.language], True, color )
        rect = txt.get_rect()
        rect.left = (self.bg_size[0] - rect.width) //2 + x
        rect.top = (self.bg_size[1] - rect.height) //2 + y
        self.screen.blit( txt, rect )
        return rect

# -----------------------------------------------------------------------------------------
# ------------------------------- ÂàÜÂÖ≥Âç°ÁöÑÊïå‰∫∫ÁßªÂä®ÂáΩÊï∞Áæ§ ------------------------------------
# -----------------------------------------------------------------------------------------
# ÈúÄË¶ÅÈ¢ùÂ§ñ‰º†ÂÖ•heroesÂèÇÊï∞ÊòØÂõ†‰∏∫Ë¶ÅÂèØÂú®‰∏§‰∏™modelÂÜÖÂùáÂèØÁî®Ôºå‰ΩÜ‰∏§‰∏™ÂáΩÊï∞ÁöÑheroÂºïÁî®ÊñπÂºè‰∏çÂêå„ÄÇ
def moveMonsStg1(self, item, heroes):
    if item.category == "infernoFire":
        item.move( self.delay, heroes, self.spurtCanvas )
        self.screen.blit(item.image, item.rect)
    elif item.category == "fire":
        item.move(self.delay, self.tower.groupList["-1"], self.tower.groupList[str(item.onlayer)], self.tower.getTop(item.onlayer)+self.blockSize, heroes, self.spurtCanvas, self.bg_size ) 
        self.screen.blit(item.image, item.rect)
    elif item.category == "RedDragon":
        if item.activated:
            if not self.haloCanvas.halos["monsHalo"]:
                self.haloCanvas.addHalo( "monsHalo", [430,460,490,520], (1,1,1,0), 2 )
            fdbc = item.move( heroes, self.spurtCanvas )
            if fdbc == "vib" and self.vibration==0:
                self.vibration = 6
            item.paint( self.screen )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
        elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
            item.activated = True
    elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):  # moves only if the gozilla appears in the screen
        if item.category == "gozilla" or item.category=="megaGozilla":
            item.move(self.delay, heroes)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
        elif item.category == "dragon":
            fire = item.move(self.delay)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            if fire:
                self.allElements.add(fire)
            self.screen.blit(item.image, item.rect)
        elif item.category == "blockFire":
            item.burn(self.delay, heroes, self.spurtCanvas)
            self.screen.blit(item.image, item.rect)

def moveMonsStg2(self,item, heroes):
    if item.category == "column":
        frnLayer = 0
        for hero in heroes:
            frnLayer = max(frnLayer, hero.onlayer)
        fdbc = item.move( heroes, frnLayer, self.tower.groupList )
        self.screen.blit(item.image, item.rect)
        if fdbc == "vib" and self.vibration==0:
            self.vibration = 6
        elif fdbc == "alarm":
            self.screen.blit(item.canvas, item.canvasRect)
        elif fdbc:
            self.screen.blit( fdbc[0], fdbc[1] )
    elif item.category == "stone":
        item.move(self.delay, self.tower.groupList["-1"], self.tower.groupList[str(item.onlayer)], self.tower.getTop(item.onlayer)+self.tower.blockSize, heroes, self.spurtCanvas)
        self.screen.blit(item.image, item.rect)
    elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
        if item.category == "golem":
            more = item.move( self.delay, heroes )
            if more:
                for each in more:
                    self.tower.monsters.add( each )
                    self.allElements.add( each )
                    #self.tower.layerMons[str(each.onlayer)] += 1
            if not item.doom:
                drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            elif item in self.tower.monsters:
                self.tower.monsters.remove(item)
            self.screen.blit(item.image, item.rect)
        elif item.category == "bowler":
            item.move(self.delay, heroes)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            stone = item.throw(self.delay)
            if stone:
                self.allElements.add(stone)
            self.screen.blit(item.image, item.rect) # blit item
        elif item.category == "blockStone":
            self.screen.blit(item.image, item.rect)
        elif item.category == "webWall":
            item.stick(heroes)
            item.paint(self.screen)
        elif item.category == "GiantSpider":
            self.haloCanvas.pervade = True
            item.move( self.delay, heroes, self.spurtCanvas )
            item.paint( self.screen )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )

def moveMonsStg3(self, item, heroes):
    if item.category == "Vampire":
        if item.activated:
            if not self.haloCanvas.halos["monsHalo"]:
                self.haloCanvas.addHalo( "monsHalo", [430,460,490,520], (1,1,1,0), 2 )
            minions = item.move( self.delay, heroes, self.tower.groupList )
            if minions:      # create more minions.
                for each in minions:
                    if each[0] == "skeleton":
                        mini = enemy.Skeleton(self.tower.groupList[str(item.onlayer)], self.tower.blockSize, item.onlayer)
                        mini.birth[0] = each[1][0]
                    elif each[0] == "bat":
                        mini = enemy.Bat(self.tower.groupList[str(item.onlayer+2)], item.onlayer+2)
                        mini.tgt = choice(mini.wallList)
                        mini.rect.left, mini.rect.bottom = each[1]
                    self.spurtCanvas.addSpatters( 5, [3, 4], [9, 10, 11], (80,10,80,255), each[1] )
                    self.tower.monsters.add( mini )
                    self.allElements.add( mini )
                    #self.tower.layerMons[str(mini.onlayer)] += 1
            item.paint( self.screen, self.spurtCanvas )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-10, 0, 8, item.health, item.full, 1 )
        elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
            item.activated = True
    elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
        if item.category == "skeleton":
            if not item.popping:
                item.fall( self.tower.getTop(item.onlayer), self.tower.groupList )
                drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            item.move( self.delay, heroes )
            self.screen.blit(item.image, item.rect)
        elif item.category == "dead":
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            item.move( self.delay, heroes, self.spurtCanvas )
            item.fall( self.tower.getTop(item.onlayer), self.tower.groupList )
            item.paint(self.screen)
        elif item.category == "bat":
            item.move( self.delay, heroes )
            self.screen.blit(item.image, item.rect)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-12, 0, 8, item.health, item.full, 1 )
        elif item.category == "specialWall":
            item.collapse()

def moveMonsStg4(self, item, heroes):
    if ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
        if item.category == "worm":
            keyLine = self.tower.getTop(item.onlayer)
            item.move( self.delay, self.tower.groupList[str(item.onlayer)], keyLine, self.tower.groupList["-1"], heroes )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
        elif item.category == "nest":
            more = item.move( self.delay, self.allElements, self.tower.monsters )
            if more:
                for each in more:
                    self.tower.monsters.add( each )
                    self.allElements.add( each )
                    #self.tower.layerMons[str(each.onlayer)] += 1
            else:
                drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
        elif item.category == "fly":
            item.move(self.delay, heroes)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
        elif item.category == "blockOoze":
            item.bubble( self.delay, heroes )
            self.screen.blit(item.image, item.rect)
        elif item.category == "slime":
            new = item.move(self.delay, heroes)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
            if new:
                self.tower.monsters.add(new)
                self.allElements.add(new)
                #self.tower.layerMons[str(new.onlayer)] += 1
        elif item.category == "Python":
            item.move( self.delay )
            item.paint( self.screen )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )

def moveMonsStg5(self, item, heroes):
    if item.category == "FrostTitan":
        if item.activated:
            if not self.haloCanvas.halos["monsHalo"]:
                self.haloCanvas.addHalo( "monsHalo", [430,460,490,520], (1,1,1,0), 2 )
            item.move( self.delay, heroes, self.spurtCanvas, self.bg_size )
            item.paint( self.screen )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
        elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
            item.activated = True
    elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):  # moves only if the gozilla appears in the screen
        if item.category == "wolf":
            item.move(self.delay, heroes)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
            #self.addTXT( (str(item.jumping),str(item.jumping)), 0, (255,0,0), item.rect.left-self.bg_size[0]//2, item.rect.top-self.bg_size[1]//2 )
        elif item.category == "iceTroll":
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            item.move( self.delay, heroes, self.spurtCanvas.spatters )
            self.screen.blit(item.image, item.rect)

def moveMonsStg6(self, item, heroes):
    if item.category == "fire":
        item.move(self.delay, self.tower.groupList["-1"], self.tower.groupList[str(item.onlayer)], self.tower.getTop(item.onlayer)+self.tower.blockSize, heroes, self.spurtCanvas, self.bg_size ) 
        self.screen.blit(item.image, item.rect)
    elif item.category == "WarMachine":
        if item.activated:
            if not self.haloCanvas.halos["monsHalo"]:
                self.haloCanvas.addHalo( "monsHalo", [430,460,490,520], (1,1,1,0), 2 )
            fire = item.move( self.delay, heroes, self.spurtCanvas, self.tower.groupList )
            item.paint( self.screen )
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            if fire:
                self.allElements.add(fire)
        elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):
            item.activated = True
    elif ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):  # moves only if the gozilla appears in the screen
        if item.category == "dwarf":
            item.move(self.delay, heroes)
            drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
            self.screen.blit(item.image, item.rect)
        elif item.category == "gunner":
            item.move(self.delay, heroes)
            self.screen.blit(item.canvas, item.canvasRect)
            if item.health>0:
                drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
                self.screen.blit(item.image, item.rect)
            elif item in self.tower.monsters:
                self.tower.monsters.remove(item)
        elif item.category == "fan":
            item.whirl(self.delay, heroes)
            self.screen.blit(item.image, item.rect)

def moveMonsStg7(self, item, heroes):
    if item.category == "stabber":
        item.stab(self.delay, heroes ) 
        self.screen.blit(item.image, item.rect)
    elif item.category == "guard":
        item.move(self.delay, heroes)
        drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
        item.paint( self.screen )

# ------------------------------------------------------------------------------------------
# document of the method: -- return a list with all monsters it has made (will fill the Grouplist given)
# About the parameters:
# btmLayer is the layer that only above which would the minions may appear;
# topLayer is the layer by which the minions would stop appearring;
# randRate (0-1) is the possibility that each layer may have a monster;
# mType(number1,2) is object type, indicate what kind of monster you want to make;
# tower is the mapManager Object Reference that will provide many useful variables for the process; it contains a SpriteGroup-type container that
# you wish to fill up with created minions.
def makeMons(btmLayer, topLayer, randRate, mType, tower):
    for group in tower.groupList:         # deal every odd row; group is the key (a number str of layer)
        if ( btmLayer < int(group) < topLayer ) and ( len(tower.groupList[group])>0 ) and  ( random() <= randRate ):
            if ( tower.stg==1 ):
                if mType == 1:
                    minion = enemy.Gozilla(tower.groupList[group], tower.blockSize, group)
                elif mType == 2:
                    minion = enemy.Dragon(tower.groupList[group], group, tower.boundaries)
                elif mType == 3:    # boss - Red Dragon
                    x = tower.oriPos[0] + tower.diameter*tower.blockSize
                    y = tower.getTop(int(group))+tower.blockSize
                    minion = enemy.RedDragon(x, y, group)    
            elif ( tower.stg==2 ):
                if mType == 1:
                    minion = enemy.Golem(tower.groupList[group], tower.blockSize, group)
                elif mType == 2:
                    minion = enemy.Bowler(tower.groupList[group], group)
                elif mType == 3:
                    minion = enemy.GiantSpider(tower.groupList[group], tower.blockSize, group, tower.boundaries)
                    tower.monsters.add(minion)
                    break
            elif ( tower.stg==3 ):
                if mType == 1:
                    minion = enemy.Skeleton(tower.groupList[group], tower.blockSize, group)
                elif mType == 2:
                    minion = enemy.Dead(tower.groupList[group], tower.blockSize, group)
                elif mType == 3:
                    minion = enemy.Bat(tower.groupList[group], group)
                elif mType == 4:    # boss - Vampire
                    minion = enemy.Vampire(tower.groupList, group, tower.boundaries)
                    tower.monsters.add(minion)
                    break
            elif ( tower.stg==4 ):
                if mType == 1:
                    minion = enemy.Slime(tower.groupList[group], tower.blockSize, group)
                elif mType == 2:
                    minion = enemy.Nest(tower.groupList[group], group)
                elif mType == 3:
                    XRange = (tower.boundaries[0], tower.boundaries[1])
                    y = tower.getTop(int(group))+tower.blockSize
                    minion = enemy.Fly( XRange, y, group )
                elif mType == 4:
                    minion = enemy.Python( group, tower.getTop(int(group)), tower.boundaries, tower.blockSize )
            elif ( tower.stg==5 ):
                if mType == 1:
                    minion = enemy.Wolf(tower.groupList[group], tower.blockSize, group)
                elif mType == 2:
                    minion = enemy.IceTroll(tower.groupList[group], tower.blockSize, group)
                elif mType == 3:
                    x = tower.boundaries[1] + 2*tower.blockSize
                    y = tower.getTop(int(group))+tower.blockSize
                    minion = enemy.FrostTitan(x, y, group)
            elif ( tower.stg==6 ):
                if mType == 1:
                    minion = enemy.Dwarf(tower.groupList[group], tower.blockSize, group)
                elif mType == 2:
                    minion = enemy.Gunner(tower.groupList[group], tower.blockSize, group, tower.boundaries)
                elif mType == 3:  # boss - War Machine
                    minion = enemy.WarMachine(tower.groupList, group, tower.boundaries)
                    tower.monsters.add(minion)
                    break
            elif ( tower.stg==7 ):
                if mType == 1:
                    minion = enemy.Guard(tower.groupList[group], tower.blockSize, group)
            tower.monsters.add(minion)
            #tower.layerMons[group] += 1

# ------------------------------------------------------------------------------------------
# drawHealthÂáΩÊï∞ÊñáÊ°£ÔºöReceive 7 essential parameters:
# 'surface' can be screen or surface, used to draw the health bar.
# 'x' and 'y' stand for the position of health bar, representing different meanings according to whether 'w' is zero or non-zero.
# 'w' and 'h' decide the size of the bar; (they should be over 4, and w is recommended to be times of 10)
# 'w' ÁöÑÂÄºËã•‰∏∫0ÔºåË°®Á§∫‰ΩøÁî®ÈªòËÆ§ÁöÑË°ÄÊ†ºÈïøÂ∫¶ËÆæÂÆöÔºàblockLen=10ÔºâÔºåË°ÄÊù°ÈïøÂ∫¶‰∏éË°ÄÈáèÊàêÊ≠£ÊØî„ÄÇÊ≠§Êó∂ÁöÑÂèÇÊï∞xÂ∫î‰∏∫ÂØπË±°ÁöÑ‰∏≠Á∫øÈïøÂ∫¶„ÄÇËã•‰∏∫ÈùûÈõ∂Êï∞Â≠óÔºåË°®Á§∫Ë∞ÉÁî®ËÄÖÂ∏åÊúõËá™ÂÆö‰πâË°ÄÊù°ÁöÑÈïøÂ∫¶ÔºàblockLen=wÔºâÔºåÊ≠§Êó∂Áõ¥Êé•‰ªéxÂºÄÂßãÁîªË°ÄÊù°„ÄÇ
# 'health' is current amount of health; full is the max of item's health.
# 'gap' is the width of white frame into the bar.
def drawHealth(surface, x, y, w, h, health, full, gap):
    if health < 0:
        health = 0
    if health/full >= 0.3:
        color = (0, 240, 0)
        shadeColor = (0, 160, 0)   # Ë°ÄÂùó‰∏ãÊñπÁöÑÊù°ÂΩ¢Èò¥ÂΩ±ÁöÑÈ¢úËâ≤
    elif health/full >= 0.2:       # Ë°ÄÈáèÂ∞ë‰∫é20%ÂàôÊòæÁ§∫‰∏∫Á∫¢Ëâ≤
        color = (200, 200, 0)
        shadeColor = (120, 120, 0)
    else:
        color = (255, 0, 0)
        shadeColor = (180, 0, 0)  
    blockVol = 10        # ÊØè‰∏™ÊñπÊ†ºÊª°Êó∂Ë°®Á§∫10Êª¥Ë°Ä
    if w == 0:
        blockLen = 10    # ÊØè‰∏™ÊñπÊ†ºÈïøÂ∫¶Ëá≥Â§ö‰∏∫10ÂÉèÁ¥†
        length = full + ( math.ceil( full/blockVol )-1)*gap +gap*2       # Ë°ÄÊù°ÊÄªÈïøÂ∫¶ÔºàÁ¨¨‰∫å‰∏™Êï∞ÊòØÊ†ºÂ≠ê‰∏≠Èó¥Èó¥ÈöîÁöÑÊï∞ÈáèÔºâ
        x = x-length//2
    else:
        blockLen = w     # Ëá™ÂÆö‰πâÊ†ºÂ≠êÁöÑÈïøÂ∫¶
        length = full*blockLen//blockVol + ( math.ceil( full/blockVol )-1)*gap +gap*2       # Ë°ÄÊù°ÊÄªÈïøÂ∫¶ÔºàÁ¨¨‰∫å‰∏™Êï∞ÊòØÊ†ºÂ≠ê‰∏≠Èó¥Èó¥ÈöîÁöÑÊï∞ÈáèÔºâ
    # ÁîªÂ§ñËæπÊ°ÜÔºàÁôΩËâ≤Â∫ïÊ°ÜÔºâ
    outRect = pygame.Rect( x, y, length, h )
    pygame.draw.rect( surface, (255,255,255), outRect )

    # ÁîªÂÜÖÈÉ®Ë°ÄÊ†º
    offset = 0           # Áî®‰∫éËÆ°ÁÆóÊØè‰∏™ÊñπÊ†ºÁöÑÂÅèÁßªÂÄº
    while (health >= blockVol):
        block = pygame.Rect( x+gap+offset, y+gap, blockLen, h-gap*2 )
        pygame.draw.rect( surface, color, block )
        shadow = pygame.Rect( x+gap+offset, block.bottom-gap, blockLen, gap )
        pygame.draw.rect( surface, shadeColor, shadow )
        health -= blockVol
        offset += (blockLen+gap)
    if (health > 0):     # ÂΩìÊâÄÊúâÊª°Ê†ºÈÉΩÁîªÂÆå‰πãÂêéÔºåÁîªÂâ©‰ΩôÁöÑ‰∏ÄÊ†º
        block = pygame.Rect( x+gap+offset, y+gap, health, h-gap*2 )
        pygame.draw.rect( surface, color, block )
        shadow = pygame.Rect( x+gap+offset, block.bottom-gap, health, gap )
        pygame.draw.rect( surface, shadeColor, shadow )

# ===========================================
# -----------Â∏∏Áî®ÁöÑÁîªÊñπÊ†ºsurfaceÂáΩÊï∞Ôºö---------
def drawRect(x, y, width, height, rgba, screen):
    surf = pygame.Surface( (width, height) ).convert_alpha()
    rect = surf.get_rect()
    rect.left = x
    rect.top = y
    surf.fill( rgba )
    screen.blit( surf, rect )
    return rect
    
# =============================================================================================================
# -------------------------------------------------------------------------------------------------------------
# ------------------------------------ stage running class ----------------------------------------------------
# -------------------------------------------------------------------------------------------------------------
# =============================================================================================================
class PracticeModel():
    
    allElements = None    # a big Group for all sprites in this stage
    bg_size = ()          # Â±èÂπïÁöÑÂÆΩÈ´òÔºà‰∫åÂÖÉÁªÑÔºâ
    towerH = 160
    blockSize = 72
    language = 0          # ÂàùÂßãÈªòËÆ§‰∏∫Ëã±ÊñáÔºåÂèØÂú®ÊûÑÈÄ†ÂáΩÊï∞‰∏≠ËÆæÂÆö
    fntSet = []

    stg = 0
    scrnSpd = 4           # Â±èÂπï‰∏ä‰∏ãÁßªÂä®ÁöÑÈÄüÂ∫¶ÔºåÂçï‰ΩçÂÉèÁ¥†
    delay = 120           # Âª∂Êó∂ÂèòÈáèÔºåÁî®‰∫éÂú®‰∏çÂΩ±ÂìçÊ∏∏ÊàèÊ≠£Â∏∏ËøêË°åÁöÑÊÉÖÂÜµ‰∏ãÁªôÂõæÁâáÂàáÊç¢Â¢ûÂä†Âª∂Ëøü
    msgList = []          # Áî®‰∫éÂ≠òÂÇ®Ê∂àÊÅØÁöÑÂàóË°®ÔºàÂàóË°®ÂåÖÂê´ÂàóË°®ÔºâÔºö[[heroName, incident, cntDown]]
    vibration = 0         # Cnt to indicate the vibration of the screen.
    # Âèå‰∫∫Ê®°Âºè‰∏ãÁöÑÁâπÊÆäÂèòÈáè
    frontier = 0          # ‰∏§ËÄÖ‰∏≠ÁöÑËæÉÈ´òÂÉèÁ¥†ÂÄº
    frnLayer = 0          # ‰∏§ËÄÖ‰∏≠ÁöÑËæÉÈ´òÂ±ÇÊï∞

    hero = None           # ‰øùÂ≠òheroÂØπË±°ÁöÑÂºïÁî®
    tower = None
    screen = None         # ‰øùÂ≠òÂ±èÂπïÂØπË±°ÁöÑÂºïÁî®
    clock = None
    towerBG = None        # ÂΩìÂâçÂÖ≥Âç°ÁöÑËÉåÊôØjpg
    towerBGRect = None
    nature = None         # Ëá™ÁÑ∂ÂÖÉÁ¥†ÁöÑÁîªÂ∏É
    spurtCanvas = None    # Âáª‰∏≠ÂèçÈ¶àÊ∫ÖË°ÄÁöÑÁîªÂ∏ÉÔºàÊØî‰Ω†ÊÉ≥Ë±°‰∏≠ÁöÑÊõ¥‰∏áËÉΩÔºÅ‰∏çÂè™ÊòØËÉΩÁîªË°ÄÂô¢üòÑÂòªÂòªÔºâ
    haloCanvas = None     # bossÂá∫Áé∞Êó∂ÁöÑÂÖ®Â±èÈò¥ÂΩ±ÁîªÂ∏É
    plotManager = None    # ÁÆ°ÁêÜÂâßÊÉÖ‰ø°ÊÅØ

    trainer = None        # Ëã±ÈõÑËÆ≠ÁªÉÂ∏à
    natON = True          # Ëá™ÁÑ∂Ë£ÖÈ•∞ÊïàÊûúÊòØÂê¶ÂºÄÂêØ
    music = None          # bgm ÔºàSoundÂØπË±°Ôºâ
    controller = []       # Âè≥‰∏äËßíÊéß‰ª∂
    controllerOn = []
    paused = True
    musicOn = True
    setBG = False
    gameOn = True         # Ê∏∏ÊàèÂæ™ÁéØÊ†áÂøóÔºåÈªòËÆ§‰∏∫TrueÔºåÁé©ÂÆ∂ÁÇπÂáªÈÄÄÂá∫Êó∂Âèò‰∏∫False

    # Êú¨modelÊûÑÈÄ†ÂáΩÊï∞ËØ¥ÊòéÔºö
    # heroInfo ÊòØ‰∏Ä‰∏™heroÁöÑ‰ø°ÊÅØÔºåÂåÖÊã¨heroNoÂíåËØ•Ëã±ÈõÑÁöÑkeyDic„ÄÇÂç≥ÂΩ¢Â¶ÇÔºö(VHero, keyDic1)„ÄÇ
    def __init__(self, heroInfo, trainerInfo, bg_size, screen, language, fntSet, musicObj, natON):
        
        self.allElements = pygame.sprite.Group()
        self.stg = 0
        self.screen = screen
        self.bg_size = bg_size
        self.language = language
        self.fntSet = fntSet
        self.natON = natON
        # Âè≥‰∏äËßíÁöÑÊéß‰ª∂ÂõæÁâá ÂèäÂÖ∂‰ªñÊéßÂà∂Âô®
        self.controller = [pygame.image.load("image/quit.png").convert_alpha(), pygame.image.load("image/tips.png").convert_alpha(), 
            pygame.image.load("image/BGMusic.png").convert_alpha(), pygame.image.load("image/mute.png").convert_alpha()]
        self.controllerOn = [pygame.image.load("image/quitOn.png").convert_alpha(), pygame.image.load("image/tipsOn.png").convert_alpha(), 
            pygame.image.load("image/BGMusicOn.png").convert_alpha(), pygame.image.load("image/muteOn.png").convert_alpha()]
        self.aimImg = pygame.image.load("image/aim.png").convert_alpha()
        self.clock = pygame.time.Clock()
        self.music = musicObj
        # Initialize game canvas.
        self.gameOn = True
        self.paused = True
        self.setBG = False
        self.nature = None
        if self.natON:     # Ëá™ÁÑ∂ÊïàÊûúÂèØ‰ª•ÊòØ0ÔºàÁªøËâ≤ÊµÅËê§ÔºâÔºå4ÔºàÈõ®ÔºâÔºå5ÔºàÈõ™Ôºâ‰∏≠ÁöÑÈöèÊú∫‰∏ÄÁßç„ÄÇ
            self.nature = mapManager.Nature(self.bg_size, choice([0,4,5]), 8, 1)
        self.spurtCanvas = mapManager.SpurtCanvas( self.bg_size )
        self.haloCanvas = mapManager.HaloCanvas( self.bg_size )
        # create the hero
        initPos = ( bg_size[0]//2, bg_size[1]-self.blockSize )
        self.hero = myHero.Hero(initPos, self.blockSize, heroInfo[0], {}, 1 )   # Ëã±ÈõÑÊßΩ‰∏∫Á©∫Â≠óÂÖ∏Ôºõ‰º§ÂÆ≥ÂáèËΩª‰∏∫Ê≠£Â∏∏Ôºà‰∏∫1Ôºâ
        self.hero.keyDic = heroInfo[1]
        self.hero.haloCanvas = self.haloCanvas  # Âèó‰º§ÂèçÈ¶àÁîªÂ∏É
        self.hero.hitted = self.hero.hittedRevival
        self.allElements.add(self.hero)
        # ÂâßÊÉÖÁÆ°ÁêÜÂëò
        self.plotManager = plotManager.Dialogue(0)
        # towerËÉåÊôØÂõæÁâá ÂèäÂÖ∂ÁßªÂä®ÈÄüÂ∫¶
        self.towerBG = pygame.image.load( "image/stg"+ str(self.stg) +"/towerBG.jpg" ).convert()
        self.towerBGRect = self.towerBG.get_rect()
        self.towerBGRect.left = (self.bg_size[0]-self.towerBGRect.width) // 2
        self.towerBGRect.top = (self.bg_size[1]-self.towerBGRect.height) // 2
        # create the map
        self.tower = mapManager.PracticeTower(self.bg_size, self.blockSize)
        self.tower.generateMap()
        self.pool = enemy.Pool(self.bg_size, self.blockSize*2)

        # ËÆ≠ÁªÉÂ∏à„ÄÇ
        pos = (self.tower.house.rect.left, self.tower.house.rect.bottom)
        self.trainer = myHero.Trainer(self.bg_size, self.blockSize, trainerInfo[0], self.hero, pos)
        self.trainer.hitted = self.trainer.hittedRevival
        # self.allElements.add(self.trainer)
        # add elems of each area to the allElements and hero's checkList.
        for key in self.tower.groupList:
            for brick in self.tower.groupList[key]:
                self.allElements.add( brick )    # Âä†ÂÖ•walls
                if key=="-1":
                    self.hero.checkList.add( brick )
                    self.trainer.checkList.add( brick )
        for elem in self.tower.elemList:
            self.allElements.add(elem)
            self.hero.checkList.add(elem)
            self.trainer.checkList.add( elem )
        self.allElements.add(self.tower.house)
        # create natural impediments and monsters for each area.
        for group in self.tower.groupList:         # deal every odd row; group is the key (a number str of layer)
            if int(group)>0 and ( len(self.tower.groupList[group])>0 ) and  ( random() <= 0.9 ):
                minion = enemy.Strawman(self.tower.groupList[group], self.tower.blockSize, group)
                self.tower.monsters.add(minion)
                self.allElements.add(minion)

    def go(self):
        self.music.play(-1)
        self.screen.fill( (0, 0, 0) )
        self.screen.blit( self.towerBG, self.towerBGRect )
        for item in self.allElements:
            self.screen.blit( item.image, item.rect )
        while self.gameOn:
            if not self.paused: # Ëã•Êú™ÊöÇÂÅú
                # respond to the player's ongoing keydown event
                # get the list including the boolean status of all keys:
                key_pressed = pygame.key.get_pressed()
                if key_pressed[ self.hero.keyDic["leftKey"] ]:
                    self.hero.moveX( self.delay, "left" )
                elif key_pressed[ self.hero.keyDic["rightKey"] ]:
                    self.hero.moveX( self.delay, "right" )
                self.frontier = min(self.bg_size[1], self.hero.rect.bottom)
                self.frnLayer = max(0, self.hero.onlayer)
                
                # move all if the screen need to be adjusted.
                gap = ( self.bg_size[0] - (self.tower.boundaries[0]+self.tower.boundaries[1]) ) //2
                if gap:
                    lvl = min(gap, 10) if gap>0 else max(gap, -10)
                    self.tower.level( lvl )
                    for elem in self.allElements:
                        elem.level( lvl )
                
                # check hero's jump and fall:
                # Ëã•Â§Ñ‰∫éË∑≥Ë∑ÉÁä∂ÊÄÅÔºåÂàôÊâßË°åË∑≥Ë∑ÉÂáΩÊï∞
                if self.hero.k1 > 0:
                    self.hero.jump( self.tower.getTop(self.hero.onlayer+1) )
                # Âê¶ÂàôÔºåÊâßË°åÊéâËêΩÂáΩÊï∞
                else:
                    fallChecks = self.tower.groupList[str(self.hero.onlayer-1)]
                    if self.hero.rect.bottom <= self.tower.house.rect.top+2:
                        self.hero.checkList.add( self.tower.house )
                    self.hero.fall(self.tower.getTop(self.hero.onlayer-1), fallChecks, self.stg, self.tower.heightList)
                
                # ÊØèÈöî‰∏ÄÊÆµÊó∂Èó¥Âú®Â±èÂπïËåÉÂõ¥ÂÜÖÁîüÊàê‰∏ÄÊ≥¢strawManÔºå‰∏äÈôê‰∏∫4.
                if not ( self.delay % 60 ) and len(self.tower.monsters)<=3 and random() <= 0.3:
                    line = choice( ["1","3","5"] )
                    minion = enemy.Strawman(self.tower.groupList[line], self.blockSize, line)
                    self.tower.monsters.add(minion)
                    self.allElements.add(minion)
                
                # repaint all elements
                self.screen.blit( self.towerBG, self.towerBGRect )
                for item in self.allElements:
                    self.moveMons( item, [self.hero] )       # ÂàÜÂÖ≥Âç°Â§ÑÁêÜÊâÄÊúâÁöÑÊïå‰∫∫ÔºàËá™ÁÑ∂ÈòªÁ¢çÂíåÊÄ™ÂÖΩÔºâ„ÄÇÁî±‰∫éÊòØË¶ÜÁõñÁöÑÂáΩÊï∞ÔºåÈúÄË¶ÅÁªôselfÂèÇÊï∞„ÄÇ
                    if item.category=="lineWall" or item.category=="baseWall" or item.category=="sideWall" or item.category=="specialWall":
                        item.paint(self.screen)
                    elif item.category == "lineDecor":
                        item.alter()
                        self.screen.blit(item.image, item.rect)
                    elif item.category=="house":
                        item.paint(self.screen, self.spurtCanvas, self.fntSet[0], self.language )
                    # Â§ÑÁêÜÊäïÊé∑Áâ©ÔºöÊäïÊé∑Áâ©ÁöÑmoveÂáΩÊï∞Â∞ÜËøîÂõû‰∏âÁßçÊÉÖÂÜµÔºö1.ËøîÂõûFalseÔºåË°®Á§∫Êú™ÂëΩ‰∏≠Ôºõ2.ËøîÂõûÂåÖÂê´‰∏§‰∏™ÂÖÉÁ¥†ÁöÑÂÖÉÁªÑÔºåÂê´‰πâÂàÜÂà´‰∏∫ÊäïÊé∑Áâ©ÁöÑÊñπÂêë‚Äúright‚ÄùÊàñ‚Äúleft‚ÄùÔºå‰ª•ÂèäÊäïÊé∑Áâ©Âáª‰∏≠ÁöÑÂùêÊ†áÔºàxÔºåyÔºâÔºõ
                    # 3.ËøîÂõûÂåÖÂê´‰∏â‰∏™ÂÖÉÁ¥†ÁöÑÂÖÉÁªÑÔºåÁ¨¨‰∏â‰∏™ÂÖÉÁªÑ‰∏∫Ê†áÂøóÂëΩ‰∏≠ÁõÆÊ†áÊòØÂê¶Ê≠ª‰∫°„ÄÇ
                    elif item.category=="bullet" or item.category=="bulletPlus":
                        if item.owner.category=="hero":
                            tgts = self.tower.monsters
                            if self.trainer not in tgts:
                                tgts.add(self.trainer)
                        else:
                            tgts = [self.hero]     # ÊòØtrainerÂèëÂá∫ÁöÑÂºπËçØÔºåÁõÆÊ†áÊòØÁé©ÂÆ∂„ÄÇ
                        if item.category=="bullet":
                            item.move(tgts, self.spurtCanvas, self.bg_size)
                        else:
                            item.move(item, self.delay, tgts, self.spurtCanvas, self.bg_size) # ËøôÈáåËøòË¶Å‰º†ÂÖ•ÊäïÊé∑Áâ©Êú¨Ë∫´
                        self.screen.blit(item.image, item.rect)
                
                # Êìç‰ΩúËÆ≠ÁªÉÂ∏à„ÄÇ
                if self.trainer:
                    # check trainer's jump and fall:
                    # Ëã•Â§Ñ‰∫éË∑≥Ë∑ÉÁä∂ÊÄÅÔºåÂàôÊâßË°åË∑≥Ë∑ÉÂáΩÊï∞
                    if self.trainer.k1 > 0:
                        self.trainer.jump( self.tower.getTop(self.trainer.onlayer+1) )
                    # Âê¶ÂàôÔºåÊâßË°åÊéâËêΩÂáΩÊï∞
                    else:
                        fallChecks = self.tower.groupList[str(self.trainer.onlayer-1)]
                        if self.trainer.rect.bottom <= self.tower.house.rect.top+2:
                            self.trainer.checkList.add( self.tower.house )
                        self.trainer.fall(self.tower.getTop(self.trainer.onlayer-1), fallChecks, self.stg, self.tower.heightList)
                    self.trainer.decideAction(self.delay, self.tower.heightList, self.allElements)
                    self.trainer.checkImg( self.delay, self.spurtCanvas, [self.hero] )
                    self.trainer.paint(self.screen)
                    drawHealth( self.screen, self.trainer.rect.left+self.trainer.rect.width//2, self.trainer.rect.top-8, 0, 8, self.trainer.health, self.trainer.full, 1 )

                if self.delay <= 120:
                    for each in self.tower.monsters:
                        self.addSymm( self.aimImg, enemy.getPos(each,0.5,0.5)[0]-480, enemy.getPos(each,0.5,0.5)[1]-360)

                # decide the image of Hero
                self.hero.checkImg( self.delay, self.spurtCanvas, self.tower.monsters )
                self.hero.paint( self.screen )
                drawHealth( self.screen, self.hero.rect.left+self.hero.rect.width//2, self.hero.rect.top-8, 0, 8, self.hero.health, self.hero.full, 1 )
                if len(self.hero.jmpInfo)>0:        # ÁªòÁîªË∑≥Ë∑ÉÁÉüÂ∞òÊïàÊûú
                    self.screen.blit( self.hero.jmpInfo[0], self.hero.jmpInfo[1] )
                # ‰ªéheroÁöÑpreyList‰ø°ÊÅØÂàóË°®‰∏≠ÂèñÂáª‰∏≠‰ø°ÊÅØ„ÄÇ
                for hitInfo in self.hero.preyList:
                    self.spurtCanvas.addSpatters( hitInfo[3], [2, 3, 4], [10, 11, 12], hitInfo[2], hitInfo[1])
                self.hero.preyList = []    # ÊØèÊ¨°Âà∑Êñ∞ËØªÂèñÊâÄÊúâ‰ø°ÊÅØÂêéÔºåÂ∞ÜlistÈáçÁΩÆ‰∏∫Á©∫Ë°®
                self.hero.eventList = []   # Ê≤°ÊúâÂÆùÁÆ±‰∫ã‰ª∂Ôºå‰πüÊ≤°ÊúâÂÖ∂‰ªñËß¶Âèë‰∫ã‰ª∂ÔºåÊïÖÁΩÆ‰∏∫Á©∫‰ª•Èò≤Ê∫¢Âá∫

                if self.vibration > 0:
                    if (self.vibration % 2 == 0):
                        for elem in self.allElements:
                            elem.lift(4)
                            elem.level(4)
                    elif (self.vibration % 2 == 1):
                        for elem in self.allElements:
                            elem.lift(-4)
                            elem.level(-4)
                    self.vibration -= 1

                # Pool & ÁªòÂà∂‰∏âÂ±ÇÁîªÂ∏É
                sprites = [self.hero, self.trainer]
                #for each in self.tower.monsters:
                #    sprites.append(each)
                self.pool.flow( self.delay, self.screen, sprites, self.spurtCanvas )
                self.screen.blit( self.pool.canvas, self.pool.canvasRect )
                if self.spurtCanvas:
                    self.spurtCanvas.update(self.screen)
                if self.haloCanvas:
                    self.haloCanvas.update( self.delay, self.screen )
                if self.nature:
                    self.nature.update(self.screen)

                pos = pygame.mouse.get_pos()
                bannerList = self.renderBanner(pos)
                back = bannerList[0]
                tips = bannerList[3]
                BGMusic = bannerList[4]
                # check big events.
                heroC = enemy.getPos(self.hero, 0.5, 0.5)[0]
                if heroC<0 or heroC>self.bg_size[0]:
                    self.music.stop()
                    self.clearAll()
                    self.gameOn = False
                    return [False]

            else:
                # ÈÄèÊòéÁÅ∞Ëâ≤ÊâìÂ∫ï
                if not self.setBG:
                    self.setBG = True
                    drawRect( 0, 0, self.bg_size[0], self.bg_size[1], (0,0,0,180), self.screen )
                    tip = choice( self.plotManager.tips )
                # Âä†Board to represent some tips.
                self.addSymm( pygame.image.load("image/cardBoard.png"), 0, 0 )
                self.addSymm( pygame.image.load("image/Enter.png").convert_alpha(), 0, -60 )
                self.addTXT( ["continue/pause","ÁªßÁª≠/ÊöÇÂÅú"], 0, (20,20,20), 0, -30)
                # tip area. 
                drawRect( self.bg_size[0]//2-240, self.bg_size[1]//2+20, 480, 100, (210,180,120,120), self.screen )
                topAlign = 50
                for line in tip:
                    self.addTXT( line, 0, (0,0,0), 0, topAlign )
                    topAlign += 20
                    
            # ‰∏ÄÊ¨°ÊÄßÁöÑÈº†Ê†áÁÇπÂáªÊàñÊåâÈîÆ‰∫ã‰ª∂
            for event in pygame.event.get():
                if ( event.type == QUIT ):
                    pygame.quit()
                    sys.exit()
                elif ( event.type == KEYDOWN ):
                    if not self.paused:
                            if ( event.key == self.hero.keyDic["wrestleKey"] ):   # Êå•ÂàÄ
                                self.hero.whip()
                            elif ( event.key == self.hero.keyDic["jumpKey"] ):    # Ë∑≥Ë∑É
                                if ( self.hero.k1 > 0 ) and ( self.hero.k2 == 0 ):
                                    self.hero.k2 = 1
                                if not self.hero.trapper and self.hero.aground and ( self.hero.k1 == 0 ):
                                    self.hero.k1 = 1
                            elif ( event.key == self.hero.keyDic["shootKey"] ) and self.hero.affected<0:    # Â∞ÑÁÆ≠
                                self.hero.shoot( self.allElements, self.delay )
                                self.hero.arrow = 12
                            elif ( event.key == self.hero.keyDic["itemKey"] ):    # ‰ΩøÁî®ËÉåÂåÖÁâ©ÂìÅ
                                self.hero.useItem( self.spurtCanvas )
                            elif ( event.key == self.hero.keyDic["downKey"] ):    # ‰∏ãË∑≥
                                self.hero.shiftLayer(-2, self.tower.heightList)
                            elif ( event.key == self.hero.keyDic["bagKey"] ):     # ÂàáÊç¢ËÉåÂåÖÁâ©ÂìÅ
                                self.hero.bagPt = (self.hero.bagPt + 1) % len(self.hero.bagBuf)
                            # elif ( event.key == pygame.K_u ):              # ÁâπÊÆäÊäÄËÉΩ
                            #     self.hero.special()
                    if ( event.key == pygame.K_RETURN ):          # ÊöÇÂÅú/Ëß£Èô§ÊöÇÂÅú
                        self.paused = not self.paused
                        self.setBG = False # Áî®‰ª•ÊåáÁ§∫ÂèØ‰ª•Èì∫‰∏ÄÂ±ÇÈÄèÊòéËÉåÊôØ
                elif event.type == pygame.MOUSEBUTTONUP:          # Èº†Ê†á‰∫ã‰ª∂
                    if not self.paused:
                        if ( back.left < pos[0] < back.right ) and ( back.top < pos[1] < back.bottom ):  # ÈÄÄÂá∫ÔºàÊîæÂºÉÔºâÂΩìÂâçÂÖ≥Âç°
                            self.music.stop()
                            self.clearAll()
                            self.gameOn = False
                            return [False]
                        elif ( tips.left < pos[0] < tips.right ) and (tips.top < pos[1] < tips.bottom ):
                            self.paused = not self.paused
                        elif ( BGMusic.left < pos[0] < BGMusic.right ) and (BGMusic.top < pos[1] < BGMusic.bottom ):
                            if self.musicOn:
                                self.music.stop()
                                self.musicOn = False
                            else:
                                self.music.play(-1)
                                self.musicOn = True
            pygame.display.flip()   # from buffer area load the pic to the screen

            self.delay -= 1
            if not self.delay:
                self.delay = 240
            self.clock.tick(60)

    # ---- clear all elements in the current area ----
    def clearAll(self):
        for each in self.allElements:
            each.kill()
            del each
    
    # ========================================================================
    # ================= Áî®‰∫éÊ£ÄÊµãitem‰∏∫Êïå‰∫∫ÁöÑÊÉÖÂÜµ‰∏ãÔºåÂπ∂ÁßªÂä®ËØ•Êïå‰∫∫ ================
    # Â∞ÜËøô‰∏ÄÈÉ®ÂàÜ‰ªégo()ÂàÜÁ¶ªÂá∫Êù•ÁöÑÁõÆÁöÑÊòØ‰∏çËÆ©‰∏ªÂáΩÊï∞ÊòæÂæóËøá‰∫éÂ∫ûÂ§ßÔºåÂçïÁã¨Êàê‰∏∫‰∏Ä‰∏™ËæÖÂä©ÂáΩÊï∞ÊúâÂä©‰∫é‰πãÂêéÁöÑÁª¥Êä§Âíå‰øÆÊîπ
    # ========================================================================
    def moveMons(self, item, heroes):
        if ( item.rect.bottom >= 0 ) and ( item.rect.top <= self.bg_size[1] ):  # moves only if the gozilla appears in the screen
            if item.category == "strawman":
                item.move(self.delay, heroes)
                drawHealth( self.screen, item.rect.left+item.rect.width//2, item.rect.top-8, 0, 8, item.health, item.full, 1 )
                self.screen.blit(item.image, item.rect)
            elif item.category == "crop":
                item.move()
                self.screen.blit(item.image, item.rect)

    # --- paint upper banner (contains 3 sections) ---
    def renderBanner(self, pos):
        # paint 4 background sections and get their rect.
        sect1 = drawRect(20, 10, 60, 40, (0,0,0,120), self.screen)    # Back Option.
        sect2 = drawRect(100, 10, 120, 40, (0,0,0,120), self.screen)  # Practice Model.
        sect3 = drawRect(240, 10, 540, 40, (0,0,0,120), self.screen)  # Msg Option.
        sect4 = drawRect(800, 10, 60, 40, (0,0,0,120), self.screen)   # Tip Option.
        sect5 = drawRect(880, 10, 60, 40, (0,0,0,120), self.screen)   # Music Option.
        # give banner info.
        ctr = (sect1.left+sect1.width//2-self.bg_size[0]//2, sect1.top+sect1.height//2-self.bg_size[1]//2)  # Êõ¥Êîπ‰∏∫‰∏≠ÂøÉÂùêÊ†áÁ≥ªÁªüÁöÑ‰∏≠ÂøÉÁÇπÂèÇÊï∞
        back = self.addSymm( pygame.image.load("image/back.png").convert_alpha(), ctr[0], ctr[1] )   # ËøîÂõûÁÆ≠Â§¥
        if ( back.left < pos[0] < back.right ) and ( back.top < pos[1] < back.bottom ):  # ÈÄÄÂá∫ÔºàÊîæÂºÉÔºâÂΩìÂâçÂÖ≥Âç°
            back = self.addSymm( pygame.image.load("image/backOn.png").convert_alpha(), ctr[0], ctr[1] )
            self.addTXT( ("quit","ÊîæÂºÉ"), 0, (255,255,255), ctr[0], ctr[1] )

        ctr = (sect2.left+sect2.width//2-self.bg_size[0]//2, sect2.top+sect2.height//2-self.bg_size[1]//2)
        self.addTXT( ("Practice", "ËÆ≠ÁªÉÂú∫"), 1, (255,255,255), ctr[0], ctr[1] )

        ctr = (sect4.left+sect4.width//2-self.bg_size[0]//2, sect4.top+sect4.height//2-self.bg_size[1]//2)
        tips = self.addSymm( self.controller[1], ctr[0], ctr[1] )
        if ( tips.left < pos[0] < tips.right ) and (tips.top < pos[1] < tips.bottom ):
            tips = self.addSymm( self.controllerOn[1], ctr[0], ctr[1])
            self.addTXT( ("tips","Â∏ÆÂä©"), 0, (255,255,255), ctr[0], ctr[1] )

        ctr = (sect5.left+sect5.width//2-self.bg_size[0]//2, sect5.top+sect5.height//2-self.bg_size[1]//2)
        BGMusic = self.addSymm( self.controller[2], ctr[0], ctr[1] ) if self.musicOn else self.addSymm( self.controller[3], ctr[0], ctr[1] )
        if ( BGMusic.left < pos[0] < BGMusic.right ) and (BGMusic.top < pos[1] < BGMusic.bottom ):
            if self.musicOn:
                BGMusic = self.addSymm( self.controllerOn[2], ctr[0], ctr[1] )
                self.addTXT( ("music off","ÂÖ≥Èó≠Èü≥‰πê"), 0, (255,255,255), ctr[0], ctr[1] )
            else:
                BGMusic = self.addSymm( self.controllerOn[3], ctr[0], ctr[1] )
                self.addTXT( ("music on","ÂºÄÂêØÈü≥‰πê"), 0, (255,255,255), ctr[0], ctr[1] )

        return (sect1, sect2, sect3, sect4, sect5)
                
    # ===========================================
    # SurfaceÂØπË±°Ôºõ xÔºåy‰∏∫Ê≠£Ë¥üÔºàÂÅèÁ¶ªÂ±èÂπï‰∏≠ÂøÉÁÇπÔºâÂÉèÁ¥†ÂÄºÔºåÁ°ÆÂÆö‰∫ÜÂõæÂÉèÁöÑ‰∏≠ÁÇπÂùêÊ†á
    def addSymm(self, surface, x, y):
        rect = surface.get_rect()
        rect.left = (self.bg_size[0] - rect.width) // 2 + x
        rect.top = (self.bg_size[1] - rect.height) // 2 + y
        self.screen.blit( surface, rect )
        return rect   # ËøîÂõûÂõæÁâáÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØ‰ª•‰æõÊõ¥Â§öÊìç‰Ωú

    # ===========================================
    # x,y‰∏∫Ê≠£Ë¥üÔºàÂÅèÁ¶ªÂ±èÂπï‰∏≠ÂøÉÁÇπÔºâÂÉèÁ¥†ÂÄºÔºåÁ°ÆÂÆö‰∫ÜÊñáÂ≠óË°åÁöÑÂ∑¶‰∏äËßíÂùêÊ†á„ÄÇËøôÊ†∑ÊîπÂä®ÊòØ‰∏∫‰∫ÜÂíåaddSymm()ÂáΩÊï∞‰øùÊåÅ‰∏Ä‰∏™Áõ∏ÂØπÁªü‰∏ÄÁöÑÁ≥ªÁªü„ÄÇ
    def addTXT(self, txtList, fntSize, color, x, y):
        txt = self.fntSet[fntSize][self.language].render( txtList[self.language], True, color )
        rect = txt.get_rect()
        rect.left = (self.bg_size[0] - rect.width) //2 + x
        rect.top = (self.bg_size[1] - rect.height) //2 + y
        self.screen.blit( txt, rect )
        return rect
